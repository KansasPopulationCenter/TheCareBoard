---
title: "market_datum"
format: html
editor: visual
---

## Market Datum

This workflow builds age-by-care-focus “market” estimates of caregiving need and caregiving provision by age and care focus. We utilize the data from ATUS to create the data informed estimates of the amount of care a person of a specific age group needs and the amount of care a person of a specific age group provides. It is important to note that there is certainly large variation in the amount of care needed and provided within an age group. We utilize data to create estimates of the average amount of time needed and provided, but based on individual characteristics, this amount will likely over estimate some people and under estimate others.

### Setup

**Purpose.** Load project defaults, read the already-prepared age distribution, and initialize the base data frame of all age × care-focus combinations.

#### Initialize Final Dataframe

The first chunk loads the project defaults and required packages and reads in the data from the previous section which will act as the starting point of this analysis. We then expand the market data creating three rows for each age, one for each of the care focuses.

```{r setup_01, message=FALSE, warning=FALSE}
# Load project defaults / helpers (attaches tidyverse, janitor, etc.)
# Ensure load_defaults.R also attaches any needed extras, e.g., Hmisc for wtd.quantile
source("load_defaults.R")

# Read age distribution prepared in the separate 'market' pipeline
age_modified <- read.csv("./app_data/market.csv")

# Create a base grid of all ages × care_focus categories
market_datum <- age_modified |>
  cross_join(data.frame(care_focus = c("developmental", "daily_living", "health")))
```

#### Base ATUS setup

This chunk imports ATUS activity microdata which is used to estimate the need/provision intervals. This chunk isolates the most recent five years, excluding 2020, and constructs daily weights for the multi-year window.

```{r data_import_02, message=FALSE, warning=FALSE}
# Read ATUS activity microdata (activity-level records)
atus <- read.csv("./data/CSV/ATUSdata.csv") %>%
  select(
    YEAR, CASEID, WT06, ACTLINE, HH_SIZE, AGE, marst, nchild,
    activity, act_care_focus, occ_care_focus,
    paid_work, child_care, elder_care, sleeping,
    DURATION, SCC_ALL_LN, SEC_ALL_LN
  ) %>%
  clean_names() %>%
  # Remove a known bad ID if required by data notes
  filter(caseid != 20220402221228)

# Keep the 5 most recent years, excluding 2020 (pandemic anomaly year)
years_include <- atus |>
  distinct(year) |>
  filter(year != 2020) |>
  arrange(desc(year)) |>
  slice_head(n = 5) |>
  pull()

# Restrict ATUS to selected years and prepare working variables
atus <- atus |>
  filter(year %in% years_include) |>
  rename(care_focus = act_care_focus) |>
  mutate(
    # care_job flags occupations with any care focus
    care_job  = ifelse(occ_care_focus == "none", 0, 1),
    # Convert ATUS annual weight to an average daily weight over 5 years
    weight    = wt06 / 365 / 5,
    # Work time attributable to paid care work (used in provision construction)
    work_time = duration * paid_work * care_job
  )
```

#### Incorporate Activity Relationship Data

This chunk merges ATUS household/person-relationship fields so that we can identify household composition and respondent role (i.e. living alone, reference person, etc). The ATUS file loaded in here is a heirarchical file that is used to understand who an activity is conducted with as opposed to just what the activity is. ATUS presents the data as both activity and heirarchical level data, we utilize both to create our estimates.

```{r setup_03, message=FALSE, warning=FALSE}
# Read IPUMS ATUS Household/Person files (relationship fields)
library(ipumsr)

ddi_file <- read_ipums_ddi("./data/IPUMS Pulls/atus_00029.xml")
atus_hh   <- read_ipums_micro(ddi_file) |> clean_names()

# Join relationship info to activity rows via caseid + activity line
atus <- atus |>
  left_join(
    atus_hh |> select(caseid, actlinew, relatew),
    by = c("caseid" = "caseid", "actline" = "actlinew")
  )
```

#### Helper: Data Overrides

This chunk creates a function called prepare_overrides. This isn't important at this moment, but later on in the code for this section we will override certain deata results with our own assumptions. This function will be needed to accomplish this.

```{r data_wrangling_04, message=FALSE, warning=FALSE}
prepare_overrides <- function(care_interval, age_ranges, col_name) {
  # Stack a list of named vectors: each element corresponds to an age_range;
  # each named entry corresponds to a care_focus with an interval value.
  care_override <- do.call(rbind, lapply(names(care_interval), function(age_range) {
    data <- care_interval[[age_range]]
    data.frame(
      age_range  = age_range,
      care_focus = names(data),
      interval   = as.numeric(data)
    )
  }))

  care_override <- care_override |>
    # Expand to single-year ages by joining the age-range map
    left_join(age_ranges, by = "age_range", relationship = "many-to-many") |>
    select(age, care_focus, interval) |>
    # Name the output column (e.g., "need_override" or "provision_override")
    rename({{ col_name }} := interval)

  care_override
}
```

### Calculate Needs — Using ATUS

The next section in this document estimates the care needs of individuals (excluding child/elder care) for individuals who live alone. To undserstand how much care a person needs we look at individuals who live alone and provided no child or elder care for the day in their responses. We assume that these individuals are only providing care to themselves and thus the amount of time spent on caregiving represents the amount of care they demand. This assumption is likely somewhat flawed as it is possible that these people are providing care for others who are not in the household, such as baking food for a family member to be delivered later, but for the most part these activities are likely to be conducted for the indivdual doing them and no one else. We onlyy include activities that were conducted alone to try to limit activities that might be done to benefit a non-household member.

```{r data_wrangling_05, message=FALSE, warning=FALSE}
age <- age_modified$age
needs_atus_calc <- list()

for (a in age) {
  # 1) Restrict to individuals with NO caregiving (primary or secondary) anywhere in their diary
  data <- atus |>
    group_by(caseid) |>
    filter(all(scc_all_ln == 0)) |>
    filter(all(sec_all_ln == 0)) |>
    filter(all(child_care == 0)) |>
    filter(all(elder_care == 0)) |>
    ungroup() |>
    # Keep care activities only (exclude "non-care")
    filter(care_focus != "non-care") |>
    # Living alone (household size = 1) and reference person
    filter(hh_size == 1) |>
    filter(relatew == 100) |>
    # Stabilize with a ±2-year window around age a
    filter(age %in% c(a - 2, a - 1, a, a + 1, a + 2))

  # 2) Aggregate per person, then compute weighted mean by care_focus
  data <- data |>
    reframe(
      duration = sum(duration, na.rm = TRUE),  # total minutes per person
      weight   = first(weight),                # person-level daily weight
      .by = c(care_focus, caseid)
    ) |>
    reframe(
      need_interval = weighted.mean(duration, w = weight, na.rm = TRUE),
      .by = c(care_focus)
    ) |>
    mutate(age = a)

  if (nrow(data) > 0) needs_atus_calc[[a]] <- data
}

needs_atus_calc <- bind_rows(needs_atus_calc)
```

#### KU-Defined Overrides — Needs

As we previously mentioned, we will override certain peaces of data with predefined assumptions. The cod chunk below creates these assumptions. We use assumptions for children under the age of 18 because the ATUS only surveys individuals aged 15 and older. We also lack many data responses that fit our criteria of people who live alone for people between the age of 15 and 17 meaning we need to create estimates for this group as well.

For children under the age of 12, We assume that they need 24 hours of caregiving. This assumption comes from many state laws that require that a child is under care for 24 hours a day and it is a crime to leave them alone for any longer than that. For individuals over the age of 12 but still younger than 18 we think they need some moderate amount of care but less than 24 hours a day. We therefore assume a lower amount of careneeds for this group but one that is still higher than for 18-20 year olds.

We also provide overides for those over the age of 75. While we do have data for individuals over 75 in our data, we believe that the average person over the age of 75 who lives alone and receives no care from anyone else is likely different from the average elderly person. We therefore overide this data increasing the amount of care needed.

At the end of the day, these are assumptions. We believe they are valid assumptions but it is important to remember that these assumptions can be subject to change and people replicating this code are welcome to inser their own assumptions.

```{r chunk_06, message=FALSE, warning=FALSE}
health_0to5 <- 300
develop_0to5 <- 420
daily_0to5 <- 1440 - health_0to5 - develop_0to5

health_6to12 <- 150
develop_6to12 <- 480
daily_6to12 <- 1440 - health_6to12 - develop_6to12

health_13to18 <- 90
develop_13to18 <- 360
daily_13to18 <- 1200 - health_13to18 - develop_13to18

health_75to84 <- 200
develop_75to84 <- 0
daily_75to84 <- 780 - health_75to84 - develop_75to84

health_85 <- 300
develop_85 <- 0
daily_85 <- 1200 - health_85 - develop_85

age_ranges <- bind_rows(
  expand.grid(age_range = "age_0to5", age = c(seq(0, 5, by = 1))),
  expand.grid(age_range = "age_6to12", age = c(seq(6, 12, by = 1))),
  expand.grid(age_range = "age_13to18", age = c(seq(13, 18, by = 1))),
  
  expand.grid(age_range = "age_75to84", age = c(seq(75, 84, by = 1))),
  expand.grid(age_range = "age_85", age = 85)
) 
  
need_interval <- list(
  age_0to5 = c("developmental" = develop_0to5, 
               "health" = health_0to5, "daily_living" = daily_0to5),
  
  age_6to12 = c("developmental" = develop_6to12, 
                "health" = health_6to12, "daily_living" = daily_6to12),
  
  age_13to18 = c("developmental" = develop_13to18, 
                 "health" = health_13to18, "daily_living" = daily_13to18), 
  
  age_75to84 = c("developmental" = develop_75to84, 
                 "health" = health_75to84, "daily_living" = daily_75to84),
  
  age_85 = c("developmental" = develop_85, 
             "health" = health_85, "daily_living" = daily_85)
)

needs_ku_override <- prepare_overrides(need_interval, age_ranges, "need_override")
```

### Calculate Provision — Using ATUS

**Purpose.** This chunk transforms and combines intermediate data into the shape needed for analysis and outputs—joins, filters, and derived columns are performed here.

```{r data_wrangling_07, message=FALSE, warning=FALSE}
age <- age_modified$age 
provision_atus_calc <- list()

for(a in age){
  data <- bind_rows(
    # formal care work
    atus |>
      filter(activity == "Formal Work" & occ_care_focus != "none") |> 
# Transform/add columns
      mutate(
        care_focus = occ_care_focus, 
        duration = duration 
        ),
    
    # informal care 
    atus |> filter(care_focus != "non-care"),

    # secondary child care - remove double counting
    atus |> 
      filter(scc_all_ln > 0) |>
      filter(!(activity == "Formal Work" & occ_care_focus != "none")) |> 
      filter(!(care_focus != "non-care")) |> 
      filter(sec_all_ln == 0) |>
# Transform/add columns
      mutate(
        care_focus = "developmental",
        duration = scc_all_ln
        ),
    
    # secondary elder care - remove double counting
    atus |> 
      filter(sec_all_ln > 0) |>
      filter(!(activity == "Formal Work" & occ_care_focus != "none")) |> 
      filter(!(care_focus != "non-care")) |> 
      filter(scc_all_ln == 0) |>      
# Transform/add columns
      mutate(
        care_focus = "health", 
        duration = sec_all_ln
        )
    )
  
  data <- data|> 
    filter(age %in% c(a-2, a-1, a, a+1, a+2)) %>%
    reframe(
      duration = sum(duration, na.rm = TRUE),
      weight = first(weight),
      .by = c(caseid, care_focus)
      ) %>%
    reframe( 
      provision_interval = wtd.quantile(
        duration, weights = weight, probs = 0.5, normwt = FALSE), 
      .by = care_focus
      ) |> 
# Transform/add columns
    mutate(age = a)

  if (nrow(data) > 0) {
    provision_atus_calc[[a]] <- data
  }
}

provision_atus_calc <- bind_rows(provision_atus_calc)
```

#### KU Defined Overrides

**Purpose.** This chunk performs a focused step in the workflow that doesn’t fit the other categories (e.g., small utilities or checks).

```{r chunk_08, message=FALSE, warning=FALSE}
health_0to18 <- 0
develop_0to18 <- 0
daily_0to18 <- 0

health_85 <- 0
develop_85 <- 0
daily_85 <- 0

provision_interval <- list(
  age_0to18 = c("developmental" = develop_0to18, 
               "health" = health_0to18, "daily_living" = daily_0to18),
  
  age_85 = c("developmental" = develop_85, 
             "health" = health_85, "daily_living" = daily_85)
)

age_ranges <- bind_rows(
  expand.grid(age_range = "age_0to18", age = c(seq(0, 18, by = 1))),
  expand.grid(age_range = "age_85", age = 85)
) 

provision_ku_override <- prepare_overrides(provision_interval, age_ranges, "provision_override")
```

### Finalize Market Datum

#### Combine Need and Provision

**Purpose.** This chunk transforms and combines intermediate data into the shape needed for analysis and outputs—joins, filters, and derived columns are performed here.

```{r data_wrangling_09, message=FALSE, warning=FALSE}
df_list <- list(
  market_datum,
  needs_atus_calc, 
  needs_ku_override, 
  provision_atus_calc, 
  provision_ku_override
) 

market_datum2 <- reduce(df_list, full_join, by = c("age", "care_focus")) |> 
# Transform/add columns
  mutate(
    need_interval = coalesce(need_override, need_interval, 0),
    provision_interval = coalesce(provision_override, provision_interval, 0)
  ) |> 
  select(age, care_focus, need_interval, provision_interval)
```

#### Plot Initial Market

**Purpose.** This chunk generates figures to quickly validate assumptions and communicate patterns in the data.

```{r visualization_10, message=FALSE, warning=FALSE}
# Generate diagnostic/summary plot
plot_market <- function(df){
  df_total <- df |> 
# Group data for aggregation
    group_by(age) |> 
# Summarise grouped data
    summarise(
      total_need = sum(need_interval)/60, 
      total_provision = -sum(provision_interval)/60
      )
  
    need <- comma(round(sum(df_total$total_need)))
    provision <- comma(round(sum(df_total$total_provision)))
    sel_title <- paste0("total need: ", need, "  total provision: ", provision)
  

  p <- ggplot(data = df_total, aes(x = age)) +
    geom_col(aes(y = total_need), fill = "grey") +
    geom_col(aes(y = total_provision), fill = "steelblue") +
    theme_minimal() +
    theme(axis.title = element_blank()) +
    ggtitle(sel_title)
  
  print(p)
}

# Generate diagnostic/summary plot
plot_market(market_datum2)
```

#### Smoothing Function

**Purpose.** This chunk generates figures to quickly validate assumptions and communicate patterns in the data.

```{r visualization_11, message=FALSE, warning=FALSE}
#Define function for smoothing while keeping within bounds
smooth_data <- function(df) {
  df %>%
# Group data for aggregation
    group_by(care_focus) %>%
    arrange(age) %>%  
# Transform/add columns
    mutate(
      smoothed_need = predict(
        loess(need_interval ~ age, data = cur_data(), span = 0.2), 
        newdata = data.frame(age = age)), 
      min_val_need = min(need_interval, na.rm = TRUE),
      max_val_need = max(need_interval, na.rm = TRUE),
      smoothed_need = pmax(pmin(smoothed_need, max_val_need), min_val_need), 

      smoothed_prov = predict(
        loess(provision_interval ~ age, data = cur_data(), span = 0.3), 
        newdata = data.frame(age = age)), 
      min_val_prov = min(provision_interval, na.rm = TRUE),
      max_val_prov = max(provision_interval, na.rm = TRUE),
      smoothed_prov = pmax(pmin(smoothed_prov, max_val_prov), min_val_prov) 
    ) %>%
    ungroup()
}

# Apply smoothing function to your dataset
market_datum_smoothed <- smooth_data(market_datum2) %>%
  select(age, care_focus, smoothed_need, smoothed_prov) %>%
  rename("need_interval" = smoothed_need) %>%
  rename("provision_interval" = smoothed_prov)

# Generate diagnostic/summary plot
plot_market(market_datum_smoothed)
```

#### Final Overrides

##### Needs

**Purpose.** This chunk performs a focused step in the workflow that doesn’t fit the other categories (e.g., small utilities or checks).

```{r chunk_12, message=FALSE, warning=FALSE}
health_0to5 <- 300
develop_0to5 <- 420
daily_0to5 <- 1440 - health_0to5 - develop_0to5

health_6to12 <- 150
develop_6to12 <- 480
daily_6to12 <- 1440 - health_6to12 - develop_6to12

#health_85 <- 300
#develop_85 <- 0
#daily_85 = 1200 - health_85 - develop_85

need_interval <- list(
  age_0to5 = c("developmental" = develop_0to5, 
               "health" = health_0to5, "daily_living" = daily_0to5),
  
  age_6to12 = c("developmental" = develop_6to12, 
                "health" = health_6to12, "daily_living" = daily_6to12)
)
  
#  age_85 = c("developmental" = develop_85, 
#             "health" = health_85, "daily_living" = daily_85)
#)

age_ranges <- bind_rows(
  expand.grid(age_range = "age_0to5", age = c(seq(0, 5, by = 1))),
  expand.grid(age_range = "age_6to12", age = c(seq(6, 12, by = 1))))
              
              
              
expand.grid(age_range = "age_85", age = 85)

final_need_override <- prepare_overrides(need_interval, age_ranges, "need_override")
```

##### Provision

**Purpose.** This chunk performs a focused step in the workflow that doesn’t fit the other categories (e.g., small utilities or checks).

```{r chunk_13, message=FALSE, warning=FALSE}
no_provision <- 0

age_ranges <- bind_rows(
  expand.grid(age_range = "age_0to5", age = c(seq(0, 5, by = 1)))
) 

provision_interval <- list(
  age_0to5 = c("developmental" = no_provision, 
               "health" = no_provision, "daily_living" = no_provision)
)

final_provision_override <- prepare_overrides(provision_interval, age_ranges, "provision_override")
```

##### Care Market

**Purpose.** This chunk generates figures to quickly validate assumptions and communicate patterns in the data.

```{r visualization_14, message=FALSE, warning=FALSE}
df_list <- list(
  market_datum_smoothed,
  final_need_override,
  final_provision_override
) 

final_market_datum <- reduce(df_list, full_join, by = c("age", "care_focus")) |> 
# Transform/add columns
  mutate(
    need_interval = coalesce(need_override, need_interval, 0),
    provision_interval = coalesce(provision_override, provision_interval, 0)
  ) |> 
  select(age, care_focus, need_interval, provision_interval) |> 
  arrange(age, care_focus)

# Generate diagnostic/summary plot
plot_market(final_market_datum)

# Write output to CSV
write.csv(final_market_datum, "./app_data/market_datum.csv", row.names = FALSE)
```

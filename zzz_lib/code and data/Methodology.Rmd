---
title: "Care Board Methodology"
author: "Joseph Bommarito"
date: "`r Sys.Date()`"
output:
  word_document:
    toc: true
  html_document:
    theme: cerulean
    toc: true
    toc_float:
      collapsed: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction to the Care Board Methodology

The **Care Board** is an online dashboard designed to present comprehensive statistics and insights into the care economy - a critical yet often overlooked sector encompassing both paid and unpaid caregiving activities.
The care economy includes all tasks related to caring for oneself and others, such as nursing, teaching, childcare, and assisting elderly relatives.
These responsibilities form a significant portion of individualsâ€™ daily lives, whether through professional roles or unpaid domestic labor.

Despite its essential role in sustaining individuals, families, and society, care work remains largely invisible within formal economic statistics.
For instance, while the Bureau of Labor Statistics (BLS) tracks childcare provided by paid professionals, identical activities performed by parents remain unaccounted for.
This discrepancy highlights the broader issue of how care work is valued and measured within traditional economic frameworks.

The Care Board aims to bridge this gap by providing a centralized platform for measuring, analyzing, and studying caregiving activities in both the formal and informal sectors.
By developing novel statistics from publicly available data, the Care Board seeks to foster meaningful discussions among researchers, policymakers, and the general public, bringing greater visibility to the challenges faced by caregivers nationwide.

This document serves as the primary methodology review and repository for all statistics presented on the Care Board.
The statistics developed for the Care Board offer a new way of viewing the economy through the lens of caregiving. Where applicable, links to working papers or peer-reviewed articles will be provided.

All data presented and available for download on the Care Board, along with code and necessary information for replication, are discussed in this document.
Each section guides users through the formation of a given statistic, from raw data to its final presentation on the Care Board.
Any methodological choices, hurdles, and assumptions are documented for critical analysis and transparency.

To use this document, navigate to the section of the statistic that you are most interested in learning about.
In each section, you will find the raw data input requirements, code, and relevant explanations.

If using any data or code on the Care Board, please ensure proper attribution. Publications and reports should cite the appropriate version of the following:

Misty Heggeness, Joseph Bommarito, and Lucie Prewitt. The Care Board: Version 1.0 [dataset]. Lawrence, KS: Kansas Population Center, 2025. URL HERE


## Preliminary tasks

Before running any code, the following preliminary tasks will need to be done.
The code provided at the beginning of this document must be run before any code in any other section. This code installs relative packages and sets the working directory to be used by all other sections.

Failure to run this code may result in errors. 

Ensure that the working directory is updated to fit your data file location. Changing the working directory is needed to successfully run the code in this document.

The first step is to install the required packages.
While some statistics require some specific packages to run, other packages are needed for more general data handling.
These packages are loaded and described below.


```{r, packages}
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
  ipumsr,
  tidyverse,
  haven,
  data.table,
  Hmisc,
  DT,
  skimr,
  forcats,
  janitor,
  DescTools
)
```

-   **pacman:** is a package used to load other packages.
    This package checks to see if the other package is installed on the user's computer.
    In the case it is not installed, pacman will install it prior to loading it from the library.
    In the case it is installed, pacman will skip installation and load the package directly from the library.

-   **tidyverse:** is a commonly used data handling package in the R environment.
    Tidyverse is used to provide more streamlined and readable coding with the goal of allowing easier access to replication files.
    Whenever possible, code in this document is conducted via the tidyverse methodology as opposed to base R.

-   **haven:** is a package used for reading and writing certain data formats.
    For the purpose of this documentation, this package is mostly used for the purpose of writing datafiles as STATA .dta files.

-   **data.table:** is a package used to efficiently load and write csv files.
    Large csv files can be resource intensive to load in as a dataset.
    This package allows them to be loaded in as a table and then worked with directly in the R environment.

-   **Hmisc** is used to handle survey research and is primarily used in the below code to apply survey weights to statistics creating population valid estimates.

-   **janitor** provides simple functions for cleaning and formatting data, especially useful for cleaning column names, detecting and removing empty rows or columns, and summarizing tabular data.

-   **DT** The DT package is used exclusively for this RMD file and is used to provide more readable tables that can be viewed of the data within the HTML output.

-   **skimr** Is a package used specifically for this RMD file to provide descriptions of the appropriate datasets.

-   **DescTools** Provides a variety of functions used to describe datasets, most noteably we utilize the Gini command in this package.

```{r, workingdirectory}
data_prep_wd <- "C:/Users/sc363/OneDrive/Work Items/Workspace/CareBoard/CareBoard/02_data-prep-and-cleaning"
data_prelim_wd <- "C:/Users/sc363/OneDrive/Work Items/Workspace/CareBoard/CareBoard/01_preliminary-code-and-data"
```

To load data, you must set the working directory to the file location where your data is stored.
This code utilizes multiple folders based out of a single CareBoard directory.
Set your working directory to a general folder where the folders you download will be stored.
The code in this document will switch between directories as needed given the assumption they are all in the correct repository.
**This step is required to execute the code without errors.** 

# Data Processing

Before developing the specific statistics needed for the care board, the raw microdata files need to be compiled and converted into a proper format.
The code in this section provides a methodology to pull in all required data, clean it as necessary, and export it to the required locations.
This project uses a wide variety of data to compile it's variety of statistics but the core data represents micro data from annual surveys conducted by the census bureau and the bureau of labor statistics.
The monthly current population survey along with the yearly annual social and economic supplement and the annual american time use survey are the two largest used data sources for this project.
The first step is thus introducing how these data are loaded in and transformed to be used in our project.

## CPS ASEC Data Download

The code below produces a major source of raw data utilized in the production of the Care Board statistics: CPS monthly and CPS ASEC yearly Microdata.
The **Current Population Survey Annual Social and Economic Supplement (CPS ASEC)** is a special supplement to the **monthly Current Population Survey (CPS)**, which is conducted by the U.S. Census Bureau and the Bureau of Labor Statistics (BLS).
The **monthly CPS** is primarily focused on **labor force characteristics**, such as employment, unemployment, and workforce participation.
The  **CPS ASEC** goes beyond this by collecting detailed information on **income, poverty, health insurance coverage, and demographic characteristics**, making it the primary source of data for measuring income inequality and economic well-being in the U.S.

The **monthly CPS** is a regular survey conducted every month.
The **CPS ASEC** is conducted **once a year**, typically in **March**, and includes both regular CPS respondents and additional over sampled households to improve estimates for specific population groups.
The **CPS ASEC** expands the sample size compared to the **monthly CPS** by including **additional households** to improve data accuracy, especially for poverty and income statistics.
The **CPS Monthly data** is used for labor force statistics like the unemployment rate while the **CPS ASEC data** is used for official poverty, estimates, income distribution studies, and health insurance coverage statistics.
We utilize the **ASEC data** to compile data on income and earnings for those working in the formal care economy.

The code below uses an IPUMS API key to download the IPUMS micro_data files which include the relevant information.
**IPUMS (Integrated Public Use Microdata Series)** is a project that provides harmonized microdata from various national and international surveys and censuses.
It is maintained by the **Minnesota Population Center** at the University of Minnesota.
IPUMS makes large-scale individual- and household-level databases more accessible and comparable over time and across geographic regions.

The data available from IPUMS can be accessed through an API key.
In order to replicate the code chunk below you will need to insert your personal key into the slot for set_ipums_api_key.
For information on how to get a personal key visit https://www.ipums.org/.
An IPUMS API key is free to the public and researchers.

IPUMS CPS data, including the ASEC supplements, can be cited as follows.

Sarah Flood, Miriam King, Renae Rodgers, Steven Ruggles, J. Robert Warren, Daniel Backman, Annie Chen, Grace Cooper, Stephanie Richards, Megan Schouweiler, and Michael Westberry. IPUMS CPS: Version 12.0 [dataset]. Minneapolis, MN: IPUMS, 2024. <https://doi.org/10.18128/D030.V12.0>

When downloading from this repository, we need to first identify the sample ids that represent the required samples.
A set of files in the 01_preliminary-code-and-data file store the names of the required samples for both the asec and the cps monthly data pulls.
The key difference between these sample lists are that the asec list contains only data from the yearly asec data while the cps list contains all monthly sample iterations.

```{r Samples, eval=FALSE}
setwd(data_prelim_wd)

samples_asec <- read.csv("../01_preliminary-code-and-data/01_ASECSampleIDs.csv")$ASEC_Sample_IDs
samples_cps <- read.csv("../01_preliminary-code-and-data/01_CPSSampleIDs.csv")$CPS_Sample_IDs 
```
Following the creation of the samples, we also need to list a set of variables that we want to pull from the ipums repository.
We create three set of variables.
**var_common** refers specifically to variables that are present in both the ASEC and the CPS data.
**var_asec** refers specifically to variables that are present only in the asec data.
These variables refer mostly to income and earnings data.
**var_cps** refers specifically to variables that are present in the cps data alone.
These variables refer mostly to workforce classification variables.
The chunk below populations these lists.

```{r Variables, eval=FALSE}
# Variables to extract
var_common <- c(
  "PERNUM",
  "REGION",
  "STATEFIP",
  "SEX",
  "RACE",
  "HISPAN",
  "AGE",
  "EDUC",
  "MARST",
  "MOMLOC",
  "POPLOC",
  "FAMSIZE",
  "NCHILD",
  "YNGCH",
  "IND1990",
  "OCC2010",
  "EMPSTAT",
  "WKSTAT",
  "AHRSWORKT",
  "ABSENT",
  "WHYABSNT"
)

var_asec <- c(
  var_common,
  "EARNWT",
  "UHRSWORKT",
  "INCWAGE",
  "POVERTY"
)

var_cps <- c(
  var_common,
  "LABFORCE",
  "SPLOC",
  "COMPWT",
  "TELWRKPAY",
  "CLASSWKR",
  "DIFFCARE",
  "NILFACT"  
)
```

The code below uses the **IPUMS API** interface to pull data from the **yearly ASEC** and the **monthly cps**.
This R chunk is currently set to **NOT** run when this markdown file is ran.
The final results of this data extract can be found in the **GITHUB**.
The code does not run so that all the following code utilizes the correct iteration or the api data.
If you wish to modify the data downloaded from IPUMS simply change any of the samples or variables as you desire and then change then run the below chunk in an R script.
If you wish to simply replicate the data conducted by the Careboard, you can skip this step and load in the ddi files already in the **GITHUB** repository.

```{r Download, eval=FALSE}
setwd(data_prep_wd)

# update the following if you only want to download a specific data set list
data_sets <- c('asec', 'cps')

for(sel_data_set in data_sets){

  # Create data extract
  cps_ext_def <- define_extract_cps(
    description = "Care Variable Extract",
    samples = get(paste0('samples_', sel_data_set)),
    variables = get(paste0('var_', sel_data_set))
  )
  Sys.sleep(60)

  # Submit data extract request
  cps_ext_submitted <- submit_extract(cps_ext_def)
  cps_ext_complete <- wait_for_extract(cps_ext_submitted)

  # Download extract
  filepath <- download_extract(cps_ext_submitted, overwrite = TRUE)
  Sys.sleep(60)

  print(paste(sel_data_set, 'data has been downloaded'))
}

print("API work has finished")
```

## ATUS Data Note

As a note, the ipums data API does not currently fully support the download of **ATUS data**.
We provide the **xml** and **.dat.gz** file associated with the data in the  **GITHUB repository** for the care board.
To modify the atus data download by changing sampels or variables, users will need to conduct a manual extract from IPUMS.
The interface to conduct this manual extract along with instructions can be found as follows https://timeuse.ipums.org/.
IPUMS kindly requests that usage of this data be cited as follows.

Sarah M. Flood, Liana C. Sayer, Daniel Backman, and Annie Chen. American Time Use Survey Data Extract Builder: Version 3.2 [dataset]. College Park, MD: University of Maryland and Minneapolis, MN: IPUMS, 2023. https://doi.org/10.18128/D060.V3.2


## Data Prep Functions

After running the above code **OR** by downloading the data from the **GITHUB** repository, we should have three sets of .xml and .dat.gz files.
These files represent meta data and zipped downloads of the micro_data from IPUMS.
The code below is utilized to load this data into the R environment.

After loading the data into the R environment, we get the variable labels for each of the files.
Before creating the statistics, we need to clean the data and esnure consistancy between different samples.
The CPS and ASEC data often have variables that measure the same thing as the ATUS data but are coded slightly differently.
Thus we need to ensure that all variables are coded correctly.
This section does that while also providing information on the variety of variables throughout the samples.

```{r var list}
setwd(data_prep_wd)

ipums_asec_path <- file.path("data", "cps_00418.xml")
ddi_asec <- read_ipums_ddi(ipums_asec_path)
label_asec <- ddi_asec$var_info$var_label
lbl_tbl_asec <- ddi_asec$var_info$val_labels

ipums_cps_path <- file.path("data", "cps_00419.xml")
ddi_cps <- read_ipums_ddi(ipums_cps_path)
label_cps <- ddi_cps$var_info$var_label
lbl_tbl_cps <- ddi_cps$var_info$val_labels

ipums_atus_path <- file.path("data", "atus_00027.xml")
ddi_atus <- read_ipums_ddi(ipums_atus_path)
label_atus <- ddi_atus$var_info$var_label
lbl_tbl_atus <- ddi_atus$var_info$val_labels
```
### Asec Raw Variables

The tables below represent the different variables gathered from the ASEC data.
These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw asec}
label_asec
```


### CPS Raw Variables

The tables below represent the different variables gathered from the monthly CPS data.
These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw cps}
label_cps
```

### ATUS Raw Variables

The tables below represent the different variables gathered from the ATUS data.
These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw atus}
label_atus
```
The function below presents a methodology for comparing variables between data.
What this function does is takes the variable name in each data set and compares the value and labels together.
For example, each data set has a variable for Hispanic, but they code this data slightly differently.
The check_lookups function will, when the variable Hispanic is inserted, look at the different values to check for consistency.
In the case that different samples have different values, we will need to recode them before moving forward.

```{r}
check_lookups <- function(sel_tbl){
  index_asec <- which(str_detect(label_asec, sel_tbl))
  index_cps <- which(str_detect(label_cps, sel_tbl))
  index_atus <- which(str_detect(label_atus, sel_tbl))
    
  if(length(index_asec) > 0){
    lu_asec <- lbl_tbl_asec[[index_asec]] |> 
      rename(lbl_asec = lbl)
  } else {
    lu_asec <- data.frame(val = NA, lbl_asec = NA)
  }
  
  if(length(index_cps) > 0){
    lu_cps <- lbl_tbl_cps[[index_cps]] |> 
      rename(lbl_cps = lbl)
  } else {
    lu_cps <- data.frame(val = NA, lbl_cps = NA)
  }
  
  if(length(index_atus) > 0){
    lu_atus <- lbl_tbl_atus[[index_atus]] |> 
      rename(lbl_atus = lbl)
  } else {
    lu_atus <- data.frame(val = NA, lbl_atus = NA)
  }

  lu_combined <- lu_asec |> 
    full_join(lu_cps, by = c("val")) |>
    full_join(lu_atus, by = c("val"))

  return(lu_combined)

}
```

## Creation of new variables

In addition to the variables generated directly from IPUMS we create a few other variables of interest.
These variables represent recoding numeric variables into categorical variables or combining multiple variables into a single variable for analysis.
Each of these is coded specifically for the care board project.

### Age Category

This variable represents groupings of ages of individual respondent and acts a a categorical classifier for the different ages.
For those under the age of 18, the category "Under 18" is used.
For those over the age of sixty five, the category "Over65" is used.
For all other categories other than the 18-24, this variable represents ten year increments.

```{r age category}
f_age_category <- function(col){
  lbl <- case_when(
    col < 18 ~ "Under 18",
    col >= 18 & col < 25 ~ "Eighteen/Twenty-Four",
    col >= 25 & col < 35 ~ "Twenty-Five/Thirty-Five",
    col >= 35 & col < 45 ~ "Thirty-Five/Forty-Five",
    col >= 45 & col < 55 ~ "Forty-Five/Fifty-Five",
    col >= 55 & col < 65 ~ "Fifty-Five/Sixty-Five",
    col >= 65 ~ "Sixty-Five Plus"
    )
  
  return(lbl)
}
```

### Prime Age

This variable identifies individuals who meet the labor economics definition of being in a "prime age" bin.
Labor economics defines the prime age as the years between 25 and 55.
This age category represents people who tend to be most productive within the workforce.
The ages typically are after any higher education but before retirement.

```{r prime age}
f_prime_age <- function(col){
  lbl <- case_when(
    col < 25 ~ "Under Twenty-Five",
    col >= 25 & col < 55 ~ "Prime Age",
    col >= 55 ~ "Fifty-Five Plus"
    )
  
  return(lbl)
}
```

### Child Age

This variable looks within a house and identified the age of the youngest child, putting that value within a few age bins.
These age bins are under 5, 5-11, and 12-18 representing different aspects of a child's growth.
An additional category of eighteen plus represents adult children living with their parents while the variable NIU represents households without any children.
This variable can be used as a categorical variables instead of the numeric child age variable when desired.

```{r}
f_child_age <- function(col){
  lbl <- case_when(
    col < 5 ~ "Under Five",
    col >= 5 & col < 12 ~ "Five_Eleven",
    col >= 12 & col < 18 ~ "Twelve_Eighteen",
    col >= 18 & col < 99  ~ "Eighteen Plus",
    col == 99  ~ "NIU"
    )
  
  return(lbl)
} 
```

### Gender_parent

This variable represents an interaction between the sex and the parenthood status of an individual.
This can be one of four unique values representing both the case where a respondent is male or female and the case where the respondent is a parent or childless.

```{r gender_parent}
f_gender_parent <- function(YNGCH, sex, AGE) {
  lbl <- case_when(
    YNGCH <= 18 & sex == 'Female' & AGE >= 18 ~ "Mothers",
    YNGCH <= 18 & sex == 'Male' & AGE >= 18 ~ "Fathers",
  
    YNGCH == 99 & sex == 'Female' & AGE >= 18 ~ "Childless Women",
    YNGCH == 99 & sex == 'Male' & AGE >= 18 ~ "Childless Men",
    
    TRUE ~ "Other"
  )
  
  return(lbl)
} 
```

### Race Ethnicity

This variable coalesces the race variable and the Hispanic variable to create a single value of race_ethnicity.
It is common practice to merge these variables adding a person of Hispanic origin to the race categories as a separate observation from other races.
In the case where the respondent is not Hispanic, then this variable represents their reported survey race.

```{r}
f_race_ethnicity <- function(hispan, race){
  
  lbl <- ifelse(hispan == "Hispanic", "Hispanic", race)
  
  return(lbl)
} 
```

### Laborstatus

This variable represents a combination of the variables wkstat and empstat.
The variable empstat identifies a respondents labor force status as in the labor force, unemployed, or NILF.
The variable wkstat identifies a worker as full or part time on the condition that they are in the labor force.
Laborstatus has four unique catagories of full time, part time, unemployed, and NILF.

```{r laborstatus}
f_laborstatus <- function(wkstat, empstat){
  
  lbl <- ifelse(empstat == "Employed", wkstat, empstat)
  
  return(lbl)
}
```

### Month

This variable provides the name of the month as opposed to a numerical representation of the month for easier readability.
This variable is most important for the cps data that has monthly iterations of the data as opposed to the yearly ASEC and ATUS.

```{r}
f_month <- function(col) {
  lbl <- recode(
    as.character(col),
    `1` = "January",
    `2` = "February",
    `3` = "March",
    `4` = "April",
    `5` = "May",
    `6` = "June",
    `7` = "July",
    `8` = "August",
    `9` = "September",
    `10` = "October",
    `11` = "November",
    `12` = "December"
  )
  
  return(lbl)
} 
```

## Catagorical Variable Comparisons

Now that we have coded our major categorical variables, we need to also ensure they are coded the same between the different surveys.
To do this we utilize the lookup_compare function that we created previously.
Using this function we see the values of the different variables in the asec and atus data.

For each variable the lookup_compare function provides the value as coded in asec, cps, and atus.
For asec and cps this is generally the same, but for atus is often different.
For example the first value we look at is the varible representing hispanic origin.

### Hispanic

```{r}
lookup_compare <- check_lookups("Hispanic origin")
lookup_compare
```

As can be seen, this variable is coded in more detail in the cps data than the atus data.
We thus need to ensure all data is coded on the same format.
The functions below provide the methodology for converting the data in atus and the cps data into the final values for the hispanic data.

```{r}
f_hispanic_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `100` = "Not Hispanic",
    `9999` = "NIU",
    .default = "Hispanic"
    )
  
  return(lbl)
} 

f_hispanic_cps <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `0` = "Not Hispanic",
    `901` = "NIU",
    `902` = "NIU",
    .default = "Hispanic"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    hispan_cps = f_hispanic_cps(val),
    hispan_atus = f_hispanic_atus(val)
  ) |> 
  relocate(hispan_cps, .after = 'lbl_cps')

lookup_KU_labels
```

### Race

The code below provides the same methodology for recoding the Race variables to be identifical.

```{r}
lookup_compare <- check_lookups("Race")
lookup_compare
```


```{r}
f_race_atus <- function(col){

  lbl <- dplyr::recode(
    as.character(col),
    `100` = "White",
    `110` = "Black",
    `120` = "American Indian",
    `130` = "Asian/Pacific Island",
    `131` = "Asian/Pacific Island",
    `132` = "Asian/Pacific Island",
    `9999` = "NIU",
    .default = "Two or More Races"
    )
  
  return(lbl)
} 

f_race_cps <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `100` = "White",
    `200` = "Black",
    `300` = "American Indian",
    `650` = "Asian/Pacific Island",
    `651` = "Asian/Pacific Island",
    `652` = "Asian/Pacific Island",
    .default = "Two or More Races"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    race_cps = f_race_cps(val),
    race_atus = f_race_atus(val)
  ) |> 
  relocate(race_cps, .after = 'lbl_cps')

lookup_KU_labels
```

### Sex

The code below provides the same methodology for recoding the sex variable.

```{r}
lookup_compare <- check_lookups("Sex")
lookup_compare
```


```{r}
f_sex <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `1` = "Male", 
    `2` = "Female", 
    `9` = "NIU",
    `99` = "NIU",      
    )
  
  return(lbl)
} 


lookup_KU_labels <- lookup_compare |> 
  mutate(
    sex = f_sex(val),
  )

lookup_KU_labels
```

### Marital Status

The code below provides the same methodology for recoding the marital status variable.

```{r}
lookup_compare <- check_lookups("Marital status")
lookup_compare
```


```{r}
f_marst <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `1` = "Married",
    `2` = "Married",
    `3` = "Separated, Widowed, or Divorced",
    `4` = "Separated, Widowed, or Divorced",
    `5` = "Separated, Widowed, or Divorced",
    `6` = "Single-Never-Married",
    `7` = "Separated, Widowed, or Divorced",
    `9` = "NIU",
    `99` = "NIU",      
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    marst = f_marst(val)
  )

lookup_KU_labels
```

### Education

The variable below provides the same methodology for recoding the educaiton variable.

```{r}
lookup_compare <- check_lookups("Education|school")
lookup_compare
```

```{r}
f_educ_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
     `999` = "NIU",
     `10` = "No HS Diploma",
     `11` = "No HS Diploma",
     `12` = "No HS Diploma",
     `13` = "No HS Diploma",
     `14` = "No HS Diploma",
     `15` = "No HS Diploma",
     `16` = "No HS Diploma",
     `17` = "No HS Diploma",
     `20` = "High School",
     `21` = "High School",
     `30` = "Some College",
     `31` = "Some College",
     `32` = "Some College",
     `80` = "Some College",
     `110` = "Some College",
     `40` = "Bachelor's Degree",
     `41` = "Graduate Degree",
     `42` = "Graduate Degree",
     `43` = "Graduate Degree"
    )
  
  return(lbl)
} 

f_educ_cps<- function(col){
  
  lbl <- case_when(
    col == 999 ~ "Missing/Unknown",
    col <= 1 ~ "NIU",
    col >= 2 & col <= 72 ~ "No HS Diploma",
    col == 73 ~ "High School",
    col >= 80 & col <= 110  ~ "Some College",
    col >= 120 & col <= 122  ~ "Some College",
    col == 111 ~ "Bachelor's Degree",
    col >= 123 ~ "Graduate Degree"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    educ_cps = f_educ_cps(val),
    educ_atus = f_educ_atus(val)
  ) |> 
  relocate(educ_cps, .after = 'lbl_cps')

lookup_KU_labels
```

### Poverty

The code below provides the same methodology for the poverty variable.

```{r}
lookup_compare <- check_lookups("poverty")
lookup_compare
```

```{r}
f_poverty_asec <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `0` = "NIU",
    `10` = "Below Poverty",
    `20` = "Above Poverty",
    `21` = "100-124 Percent of Poverty",
    `22` = "125-149 Percent of Poverty",
    `23` = "150+ Percent of Poverty"    
    )
  
  return(lbl)
} 

f_poverty_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `10` = "Below Poverty",
    `11` = "Below Poverty",
    `12` = "Below Poverty",
    `20` = "Above Poverty",
    .default = "NIU"     
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    pov_asec = f_poverty_asec(val), 
    pov_atus = f_poverty_atus(val)
  ) |> 
  relocate(pov_asec, .after = "lbl_asec")

lookup_KU_labels
```

### Labor Force Status

The code below provides the same methodology for the Labor Force Status variable.

```{r}
lookup_compare <- check_lookups("Labor force status")
lookup_compare
```

```{r}
f_labforce_atus <- function(col){
  
  lbl <- case_when(
    col >= 1 & col <= 4 ~ "In the Labor Force",
    col == 5 ~ "Not in the Labor Force",
    col == 99 ~ "NIU"
    )
  
  return(lbl)
} 

f_labforce_cps <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 1 ~ "Not in the Labor Force",
    col == 2 ~ "In the Labor Force"
    )

  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    labforce_cps = f_labforce_cps(val), 
    labforce_atus = f_labforce_atus(val)
  ) |> 
  relocate(labforce_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Employment Status

The code below provides the same methodology for the Employment Status variable.


```{r}
lookup_compare <- check_lookups("Employment status")
lookup_compare
```

```{r}
f_empstat_cps <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 1 ~ "Armed Forces",
    col %in% c(10, 12) ~ "Employed",
    col >= 20 & col <= 22~ "Unemployed",
    col >= 30 & col <= 36~ "NILF"
    )
  
  return(lbl)
} 

f_empstat_atus <- function(col) {
  lbl <- recode(
    as.character(col),
    `1` = "Employed",
    `2` = "Employed",
    `3` = "Unemployed",
    `4` = "Unemployed",
    `5` = "NILF"
  )
  
  return(lbl)
}

lookup_KU_labels <- lookup_compare |> 
  mutate(
    empstat_cps = f_empstat_cps(val), 
    empstat_atus = f_empstat_atus(val)
  ) |> 
  relocate(empstat_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Work Status

The code below provides the same methodology for the variables identifiying full or part time status.

```{r}
lookup_compare <- check_lookups("Full or part time status")
lookup_compare
```

```{r}
f_wkstat <- function(col){
  
  lbl <- case_when(
    col >= 10 & col <= 15 ~ "Full Time",
    col >= 20 & col <= 22 ~ "Part Time",
    col >= 40 & col <= 42 ~ "Part Time",
    col %in% c(50, 60) ~ "Unemployed",
    col == 99 ~ "NIU"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    wkstat = f_wkstat(val),
  ) |> 
  relocate(wkstat, .after = "lbl_cps")

lookup_KU_labels
```

### Class of Worker

The code below provides the same methodology for analyzing worker classes.

```{r classwkr compare}
lookup_compare <- check_lookups("Class of worker")
lookup_compare
```

```{r classwkr recode}
f_classwkr <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 99 ~ "Missing/Unknown",
    col %in% c(10, 13, 14) ~ "Self_Employed",
    col >= 20 & col <= 23 ~ "Wage/Salary",
    col >= 24 & col <= 28 ~ "Government",
    col == 29 ~ "Unpaid"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    classwkr = f_classwkr(val),
  ) |> 
  relocate(classwkr, .after = "lbl_cps")

lookup_KU_labels
```

### NILF

The code below uses the same methodology for the question analyzing why someone is not in the labor force.,

```{r nilf compare}
lookup_compare <- check_lookups("NILF")
lookup_compare
```

```{r nilf recode}
f_nilf_actvity <- function(col){
  
  lbl <- case_when(
    col == 1 ~ "Disabled",
    col == 2 ~ "Ill",
    col == 3 ~ "School",
    col == 4 ~ "Homemaker",
    col == 6 ~ "Other",
    col == 99 ~ "NIU"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    nilf_activity = f_nilf_actvity(val),
  ) |> 
  relocate(nilf_activity, .after = "lbl_cps")

lookup_KU_labels
```

### Telework

The code below provides the same methodology for the varibale asking if someone works via telework.

```{r telework compare}
lookup_compare <- check_lookups("telework")
lookup_compare
```

```{r telework recode}
f_telwrkpay <- function(col){
  
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `1` = "Teleworked",
    `2` = "No Telework"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    telwrkpay = f_telwrkpay(val),
  ) |> 
  relocate(telwrkpay, .after = "lbl_cps")


## -----------------------------------------------------------------------------------------
lookup_compare <- check_lookups("Absent")

f_absent <- function(col){
  
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `1` = "No",
    `2` = "Yes, Laid Off",
    `3` = "Yes, Other"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    absent = f_absent(val),
  ) |> 
  relocate(absent, .after = "lbl_cps")

lookup_KU_labels
```

### Reason for Absent

The code below provides the same methodology for the variable representing the reson why someone was not at work.

```{r reason compare}
lookup_compare <- check_lookups("Reason")
lookup_compare
```

```{r why absent function}
f_whyabsnt <- function(col) {
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `5` = "Vacation/Personal days",
    `6` = "Own illness/medical problem",
    `7` = "Care Reason",
    `8` = "Care Reason",
    `9` = "Care Reason",
    `10` = "Non-Care Reason",
    `11` = "Non-Care Reason",
    `12` = "Non-Care Reason",
    `13` = "Non-Care Reason",
    `15` = "Other"
  )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    whyabsnt = f_whyabsnt(val),
  ) |> 
  relocate(whyabsnt, .after = "lbl_cps")

lookup_KU_labels
```

### Recoding all Variables

The functions created above provide the methodology to recode all needed variables.
The code chunk below creates a general function that utilizes these above functions to recode the variables ensuring that all cps, asec, and atus samples have identical variable values.
Additionally, the code below ensures that numeric variables are correctly coded and provides mutations to data variables to ensure they are all the same format.

The functions in the chunk below are split for variables in all samples, variables in both the ASEC and cps, and variables in each of the unique sampples.
For a reminder of which variables are in which see the variable classifications previously discussed.
Finallym, this code chunk creates the final column order which will be used to ensure that all data sets have their variables in the same order.


```{r Recoding Functions}

recode_all_common <- function(df) {
  if("MONTH" %in% names(df)){
    df <- df |> 
      mutate(date = 
               as.Date(paste(YEAR, MONTH, "01", sep = "-")))
  } else {
    df <- df |> 
      mutate(date = as.Date(paste(YEAR, "01-01", sep = "-")))
  }
  
  df <- df |>
    mutate(
      id = row_number(),
      nchild = as.numeric(NCHILD),
      child_age = f_child_age(YNGCH),
      age_category = f_age_category(AGE),
      prime_age = f_prime_age(AGE),
      sex = f_sex(SEX),
      marst = f_marst(MARST), 
      gender_parent = f_gender_parent(YNGCH, sex, AGE)
    )
  
  return(df)
}


recode_asec_cps <- function(df) {
  df <- df |>
    mutate(
      statefip = as_factor(STATEFIP),
      region = as_factor(REGION),
      famsize = as.numeric(FAMSIZE),
      month = f_month(MONTH),
      
      hispan = f_hispanic_cps(HISPAN),
      race = f_race_cps(RACE),
      race_ethnicity = f_race_ethnicity(hispan, race),
      educ = f_educ_cps(EDUC),

      wkstat = f_wkstat(WKSTAT),     
      empstat = f_empstat_cps(EMPSTAT), 
      laborstatus = f_laborstatus(wkstat, empstat),      
      absent = f_absent(ABSENT),
      whyabsnt = f_whyabsnt(WHYABSNT)
    )
  
  return(df)
}

recode_asec <- function(df) {
  df <- df |>
    mutate(
      pernum = as.numeric(PERNUM),
      momloc = as.numeric(MOMLOC),
      poverty = f_poverty_asec(POVERTY)
    )
  
  return(df)
}

recode_cps <- function(df) {
  df <- df |>
    mutate(
      labforce = f_labforce_cps(LABFORCE),
      classwrk = f_classwkr(CLASSWKR),
      telwrkpay = f_telwrkpay(TELWRKPAY),
      nilf_activity = f_nilf_actvity(NILFACT)
    )
  
  return(df)
}

recode_atus <- function(df) {
  df <- df |>
    mutate(
      day = case_when(
        DAY == 1 ~ "Sunday",
        DAY == 2 ~ "Monday",
        DAY == 3 ~ "Tuesday",
        DAY == 4 ~ "Wednesday",
        DAY == 5 ~ "Thursday",
        DAY == 6 ~ "Friday",
        DAY == 7 ~ "Saturday"
      ),
      
      poverty = f_poverty_atus(POVERTY185),
      hispan = f_hispanic_atus(HISPAN),
      race = f_race_atus(RACE),
      race_ethnicity = f_race_ethnicity(hispan, race),
      
      empstat = f_empstat_atus(EMPSTAT),
      educ = f_educ_atus(EDUC)
    )
    
  return(df)
}

col_order <- c(
  'id',
  'YEAR',
  'SERIAL',
  'MONTH',
  'month',
  'DAY',
  'date',
  
  'CPSID',
  'ASECFLAG',
  'HFLAG',
  'ASECWTH',
  'COMPWT',
  'WT06',
  'WT20',
  'HWTFINL',
  'WTFINL',
  'pernum',
  'CASEID',
  'STRATA',
  
  'REGION',
  'region',
  'STATEFIP',
  'statefip',
  
  'PERNUM',
  'CPSIDP',
  'CPSIDV',
  'ASECWT',
  
  'AGE',
  'age_category',
  'prime_age',
  
  'SEX',
  'sex',

  'HISPAN',
  'hispan',
  'RACE',
  'race',
  'race',
  'race_ethnicity',
  
  'MARST',
  'marst',
  'MOMLOC',
  'momloc',
  'POPLOC',
  'SPLOC',

  'gender_parent',
  'HH_SIZE',
  'FAMINCOME',
  'HH_NUMADULTS',
  'FAMSIZE',
  'famsize',
  'NCHILD',
  'nchild',
  'YNGCH',
  'child_age',
  
  'EDUC',
  'educ',
  
  'EMPSTAT',
  'empstat',
  'laborstatus',
  'OCC2010',
  'IND1990',
  'UHRSWORKT',
  'AHRSWORKT',
  'ABSENT',
  'absent',
  'WHYABSNT',
  'whyabsnt',
  'WKSTAT',
  'wkstat',
  
  'EARNWT',
  'INCWAGE',
  'POVERTY',
  'poverty',

  'LABFORCE',
  'labforce',
  'CLASSWKR',
  'classwkr',
  'NILFACT',
  'nilf_activity',
  'DIFFCARE',
  'TELWRKPAY',
  'telwrkpay',

  'KIDWAKETIME',
  'KIDBEDTIME',
  'POVERTY185',
  'LINENO',
  'OCC2',
  'OCC_CPS8',
  'EARNWEEK',
  'HRSWORKT_CPS8',
  'SPEMPSTAT',
  'ECPRIOR',
  'ACTLINE',
  'ACTIVITY',
  'DURATION_EXT',
  'DURATION',
  'SCC_ALL_LN',
  'SCC_OWN_LN',
  'SEC_ALL_LN',
  'START',
  'STOP',
  'Activity',
  'developmental',
  'health',
  'daily_living',
  'PaidWork',
  'FormalWork',
  'ChildCare',
  'ElderCare',
  'Householdcare',
  'Selfcare',
  'Leisure',
  'Sleeping',
  'Volunteering',
  'Education'
)
```

## Loading the Activity Data

In the Care Board methodology, we specifically attempt to develop ways to compare both formal paid and informal unpaid activities and time use.
We creates crosswalks from the data to code all activities as either care activities or not and as a specific care focus in the case they are a care related activity.
The classification of jobs and activities as part of the care economy or not represents a major source of assumptions and decision points.
We argue that we have classified these activities in the correct manner, but we acknowledge that others might have differing opinions about these.
We thus provide the crosswalks for analysis and review.

The first crosswalk presents the classification of formal occupations as parts of the care economy or not.
This crosswalk uses federal **standard occupational classification codes (SOC)** and for each labels it as developmental care, daily_living care, health care, or none.

```{r load occupations}
setwd(data_prelim_wd)
df_occ <- fread("01_Formal_Occupation_Crosswalk.csv")
df_occ
```

The second crosswalk presents the classification of informal timeuse activities as part of the care economy or not.
This crosswalk uses the ATUS activity codes and for each labels it as developmental care, daily_living care, health care, or none.

```{r load activities}
setwd(data_prelim_wd)
df_act <- fread("01_ATUSActivityCrossover.csv")
df_act
```


## CPS Variable Processing

Now that we have investigated the variables across our different samples we need to apply the various functions above to each of our datasets to recode them to fit the proper format.
We start with the monthly cps data
The code below uses the ddi file to load in all cps data and then applies the functions to recode the variables, assemble them in the correct order, and merge them with the activity coding data.
This then saves the files as an rds file for future use.



```{r recode cps data}
setwd(data_prep_wd)
# Read data
micro_cps <- read_ipums_micro(ddi_cps)

# Apply data processing functions to base table to get desired standard output
micro_cps <- micro_cps %>% 
  recode_all_common() |> 
  recode_asec_cps() |> 
  recode_cps() %>%
  select(any_of(col_order)) |> 
  left_join(df_occ, by = c("OCC2010" = "code"))

saveRDS(micro_cps, "03_CPSdata.rds")

skim(micro_cps)
```


## Asec Variable Processing

The code below does the same thing applying the functions created to recode the data for the asec variabels.
This code then assembles the data in the proper order and merges them with the activity data.

```{r recode asec data}
setwd(data_prep_wd)
# Read data
micro_asec <- read_ipums_micro(ddi_asec)

# Apply data processing functions to base table to get desired standard output
micro_asec <- micro_asec %>% 
  recode_all_common() |> 
  recode_asec_cps() |> 
  recode_asec() %>%
  select(any_of(col_order)) |> 
  left_join(df_occ, by = c("OCC2010" = "code"))

saveRDS(micro_asec, "03_ASECdata.rds")

skim(micro_asec)
```

## ATUS Variable Processing

The code below uses the functions created to recode the atus variables.
This code then assembles the data in the proper order and merges them with the activity data.
Following this, this code merges atus data with occupation data from the cps monthly data.
For understanding formal care economy work we rely on responses in the CPS data and utilize the CPSIDP variable to merge between atus and cps datasets.
The ATUS is conducted among a subset of individuals in the month when they leave the cps data rotation.
We utilize the data from the last month an individual is present in the cps to identify their formal occupation status for the atus data.

```{r recode atus data}
rm(micro_asec)
gc()

setwd(data_prep_wd)

micro_atus <- read_ipums_micro(ddi_atus)

# Apply data processing functions to base table to get desired standard output
micro_atus <- micro_atus %>% 
  recode_all_common() |> 
  recode_atus() |> 
  left_join(df_act, by = c("ACTIVITY" = "Code")) %>%
  select(any_of(col_order)) |> 
  mutate(
    act_care_focus = case_when(
      developmental == 1 ~ 'developmental',
      daily_living == 1 ~ 'daily_living', 
      health == 1 ~ 'health', 
      TRUE ~ 'non-care'
    )
  )

# Get occupation care_focus labels from cps data where available
cps_occ <- micro_cps |> 
  group_by(CPSIDP) |> 
  filter(date == max(date)) |> 
  ungroup() |> 
  select(CPSIDP, date, care_focus) 

rm(micro_cps)
gc()

micro_atus <- micro_atus |> 
  left_join(
    cps_occ |> rename(occ_care_focus = care_focus,  cps_date = date), 
    by = c("CPSIDP")
    )

saveRDS(micro_atus, "03_ATUSdata.rds")

skim(micro_atus)
```


## Data Processing Conclusion

The code in this section has provided the methodology for downloading, cleaning, summarizing, and saving the data utilized in the Care Board project.
This section is essential for understanding the replication methodologies to go from completly raw data to the data used to compile the individual statistics.
The code above saves 3 separate datasets for monthly cps, yearly asec, and yearly atus data.
Upon the complete running of this code, three datasets should be written into the proper working directory.

# Care needs and provision

## Age Data

## Market Datum

## Finalize Care Economy Data


# Lives of Care (Provider Demographics)

## Provider Groups

## Providers

## Provider Informal

## Provider formal data

# The Circle of Care (Activity Timeuse)

## Formal Care Activities

## Informal Care Activities

##Activity Formal Datum

## Activity Informal Datum

# Care Gini

# Care Ratio

# Labor Force Participation

## Labor Force Participation by Care Giver Status

## Formal Care Force

## Informal Care Force

# The Sandwhich Generation

The */*/Sandwich Generation*/*/ refers to a group of adults who are simultaneously caring for their own children while also providing care or support to aging parents.
This dual responsibility places unique emotional, financial, and time burdens on caregivers, often leading to stress, work-life conflict, and economic strain.
In care economics, the sandwich generation exemplifies how unpaid and invisible care giving labor supports the functioning of both the family and broader society.
Understanding this generation's experience is crucial as demographic shifts, such as increased life expectancy and delayed childbearing, intensify these caregiving demands.

Measuring the size and characteristics of the sandwich generation is essential for informing public policy, labor protections, and social support systems.
Capturing accurate numbers and understanding the demographic profile of this group, such as gender, income, employment status, and race/ethnicity, can help reveal the hidden costs of informal care and shape interventions that better support multi-generational caregivers.
Recognizing their role is vital, not just for their well-being, but also for sustaining the broader care economy.

This section provides the code and outcomes used to provide the statistics related to the care economy.
To understand the sandwich generation we utilize ATUS data.
We only utilize years after 2010 due to the year 2011 being the first year to ask questions about secondary elder care activities.
The chunk below loads in the data and selects the requested variables.

```{r load atus sandwhich}
atus <- read.csv("./data/CSV/ATUSdata.csv") |> 
  filter(YEAR >= 2011 & YEAR != 2020) |>
  select(YEAR, date, CASEID, WT06, YNGCH, AGE, 
         child_care, elder_care, DURATION,
         SCC_ALL_LN, SEC_ALL_LN, sex, race_ethnicity, empstat) |> 
  data.frame() |> 
  clean_names() 

yr_range <- atus_yr_range(atus)
```

After loading in the data we need to identify sandwiched individuals.
To do this we calculate the total amount of time that each individual spends in both child and elder care.
We consider someone to be sandwhiched in the case where the following conditions are met.

1) They are aged 18 or older.
2) They have an own child living with them aged 10 or younger.
3) They spend at least 1 minute in their day providing care to an elderly household member.

These assumptions provide a more conservative estimation by limiting the count of people in the sandwich generation to not include individuals with older or adult children.
Inclusion of these groups would lead to larger estimates of the size of the sandwich generation.


```{r flag sandwhich}
case_time <- atus |> 
  group_by(year, date, caseid, wt06, yngch, age, sex, race_ethnicity, empstat) |> 
  summarise(
    time_child_care = sum(child_care*duration + scc_all_ln),
    time_elder_care = sum(elder_care*duration + sec_all_ln),
    time_child_elder = sum(time_child_care + time_elder_care)
  ) |> 
  ungroup() 
  
case_time <- case_time |> 
  mutate(
    sandwich_all = ifelse(
      time_elder_care > 0 & yngch <= 10 & age >= 18,
      "sandwich", "other")
  )
```

Following this we calculate the data needed to feed the care board app.
This data is specifically the count and proportion of individuals who are labeled as "sandwiched."
The code below uses a 5 year rolling average method to move through the ATUS data.
ATUS has sample sizes that are small enough that they become difficult to subset at specific demographics in years.
To get around this, it becomes standard practice to utiilze 5 year rolling averages.

For each five year group, this code calculates the population of individuals, the total time spent providing care across the populaiton, and the weighted median of care provision across the sandwhiched individuals.

```{r sandwichapp data}
sandwich_stats_5yr <- list()
i = 1

for(sel_year in yr_range$year) {
  year_min <- yr_range$yr_start[i]
  
  sandwich_stats_5yr[[sel_year]] <- case_time |>
    filter(year >= year_min & year <= sel_year) |>
    group_by(sandwich_all) |>
    summarise(
      sandwich_population = sum(wt06/365)/5,
      sandwich_time_total = sum(wt06/365*time_child_elder)/5,
      sandwich_time_median = wtd.quantile(
        time_child_elder, 
        weights = wt06, 
        probs = 0.5
        )
    ) |>
    ungroup() |> 
    mutate(
      sandwich_population_proportion = sandwich_population / 
        sum(sandwich_population), 
      date = as.Date(paste0(as.character(sel_year), "-01-01"))
      ) |> 
    filter(sandwich_all == "sandwich")
  
  i = i + 1
}

sandwich_stats_5yr <- bind_rows(sandwich_stats_5yr) |> 
  select(date, sandwich_population, sandwich_population_proportion,
         sandwich_time_total, sandwich_time_median)

write.csv(sandwich_stats_5yr, "./data/CB_Dashboard_Data/sandwich_app.csv", row.names = FALSE)

datatable(
  sandwich_stats_5yr,
  options = list(
    pageLength = 10,
    scrollX = TRUE,
    autoWidth = TRUE
  ),
  caption = 'Table: Summary statistics for the sandwich generation (5-year estimates)',
  rownames = FALSE
)
```

Finally, we replicate the above analysis while accounting for different demographic characteristics.
Specifically, we look at the count and proportion among different sexes, races, and employment statuses.
This version of the data will be available for download on the Care Board GitHub.
Please note that for some of these demographic combinations, there do not exist respondents in the sample, for example NILF American Indian Females in the year 2015 had no representation in that year's ATUS sample.
As such, this group and others without a representation are exlcuded from the table.

```{r Sandwhich downloadable data}
sandwich_stats_5yr <- list()
i = 1

for(sel_year in yr_range$year) {
  year_min <- yr_range$yr_start[i]
  
  sandwich_stats_5yr[[sel_year]] <- case_time |>
    filter(year >= year_min & year <= sel_year) |>
    group_by(sandwich_all, sex, race_ethnicity, empstat) |>
    summarise(
      sandwich_population = sum(wt06/365)/5,
      sandwich_time_total = sum(wt06/365*time_child_elder)/5,
      sandwich_time_median = wtd.quantile(
        time_child_elder, 
        weights = wt06, 
        probs = 0.5
        )
    ) |>
    ungroup() |> 
    mutate(
      sandwich_population_proportion = sandwich_population / 
        sum(sandwich_population), 
      date = as.Date(paste0(as.character(sel_year), "-01-01"))
      ) |> 
    filter(sandwich_all == "sandwich")
  
  i = i + 1
}

sandwich_stats_5yr <- bind_rows(sandwich_stats_5yr) |> 
  select(date, sex, race_ethnicity, empstat, sandwich_population, sandwich_population_proportion,
         sandwich_time_total, sandwich_time_median)

write.csv(sandwich_stats_5yr, "./data/CSV/sandwichstats.csv", row.names = FALSE)
write_dta(sandwich_stats_5yr, "./data/Dta/sandwichstats.dta")

datatable(
  sandwich_stats_5yr,
  options = list(
    pageLength = 10,
    scrollX = TRUE,
    autoWidth = TRUE
  ),
  caption = 'Table: Summary statistics for the sandwich generation (5-year estimates)',
  rownames = FALSE
)
```

# The share of the Formal/Informal Care Economy

## Minutes Worked in the Formal Care Economy

## Minutes Worked in the Informal Care Economy

# Valuing the Care Economy

## Informal Care Economy Valuation.

## Formal Care Economy Valuation.

# Conclusion

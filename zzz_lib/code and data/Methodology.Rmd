---
title: "Care Board Methodology"
author: "Joseph Bommarito"
date: "2025-04-01"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float:
      collapsed: true
  word_document:
    toc: true
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

# Introduction to the Care Board Methodology

**The Care Board** is an online dashboard designed to present comprehensive statistics and insights on the care economy - a critical yet overlooked sector encompassing both paid and unpaid care activities. The care economy includes all tasks related to caring for oneself and others. This includes jobs like nursing, teaching, childcare, and assisting elderly relatives, among others. It also includes informal, unpaid care work we do in our homes like making dinner, caring for children, or washing clothes. These responsibilities form a significant portion of individuals’ daily lives, whether through professional roles or unpaid domestic labor.

Despite its essential role in sustaining individuals, families, and society, care work remains largely invisible within formal economic statistics. For instance, while the Bureau of Labor Statistics (BLS) tracks childcare provided by paid professionals, identical activities performed by parents and relatives remain unaccounted for. This discrepancy highlights the broader issue of how care work is valued and measured within traditional economic frameworks.

The Care Board aims to bridge this gap by providing a centralized platform for measuring, analyzing, and studying caregiving activities in both the formal and informal sectors. By developing novel statistics from publicly available data, the Care Board seeks to foster meaningful discussions among researchers, policymakers, and the general public, bringing greater visibility to the challenges faced by caregivers nationwide.

This document serves as the primary detailed methodology and repository for all statistics presented on The Care Board. The statistics developed for The Care Board offer a new perspective on the economy through the lens of care. Where applicable, links to working papers or peer-reviewed articles will be provided.

All data presented and available for download on The Care Board, along with code and necessary information for replication, are discussed in this document. Each section guides users through the formation of a given statistic, from raw data to its final presentation. Any methodological choices, hurdles, and assumptions are documented for transparency.

To use this document, navigate to the section of the statistic in which you are most interested in. In each section, you will find the raw data input requirements, code, and relevant explanations.
If using any data or code on the Care Board, please ensure proper attribution. Publications and reports should cite the appropriate version of the following:


Misty L. Heggeness, Joseph Bommarito, and Lucie Prewitt. The Care Board: Version 1.0 [dataset]. Lawrence, KS: Kansas Population Center, 2025. https://thecareboard.org


## Preliminary tasks

Before running any code, the following preliminary tasks will need to be done. The code provided at the beginning of this document must be run before any code in any other section. This code installs relative packages and sets the working directory to be used by all other sections.

Failure to run this code may result in errors.

Ensure that the working directory is updated to fit your data file location. Changing the working directory is needed to successfully run the code in this document.

The first step is to install the required packages. While some statistics require some specific packages to run, other packages are needed for more general data handling. These packages are loaded and described below.


### Packages
```{r packages}
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
  ipumsr, 
  tidyverse, 
  janitor,
  data.table,
  haven,
  DT,
  skimr
)

if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
  tidyverse, 
  data.table,
  haven,
  janitor, 
  ggplot2,
  scales,
  DescTools, 
  Hmisc, 
  slider, 
  readxl, 
  rlang
)

options(scipen = 999)
```

-   **pacman:** is a package used to load other packages. This package checks to see if the other package is installed on the user’s computer. In the case it is not installed, pacman will install it prior to loading it from the library. In the case it is installed, pacman will skip installation and load the package directly from the library.

-   **tidyverse:** is a commonly used data handling package in the R environment. Tidyverse is used to provide more streamlined and readable coding with the goal of allowing easier access to replication files. Whenever possible, code in this document is conducted via the tidyverse methodology as opposed to base R.

-   **haven:** is a package used for reading and writing certain data formats. For the purpose of this documentation, this package is mostly used for the purpose of writing datafiles as STATA .dta files.

-   **data.table:** is a package used to efficiently load and write csv files. Large csv files can be resource intensive to load in as a dataset. This package allows them to be loaded in as a table and then worked with directly in the R environment.

-   **Hmisc:** is used to handle survey research and is primarily used in the below code to apply survey weights to statistics creating population valid estimates.

-   **janitor:** provides simple functions for cleaning and formatting data, especially useful for cleaning column names, detecting and removing empty rows or columns, and summarizing tabular data.

-   **DT:** The DT package is used exclusively for this RMD file and is used to provide more readable tables that can be viewed of the data within the HTML output.

-   **skimr:** Is a package used specifically for this RMD file to provide descriptions of the appropriate datasets.

-   **DescTools** Provides a variety of functions used to describe datasets, most noteably we utilize the Gini command in this package.

### Working Directory
```{r, workingdirectory}
setwd(".")
```

To load data, you must set the working directory to the file location where your data is stored. This code utilizes multiple folders based out of a single CareBoard directory. Set your working directory to a general folder where the folders you download will be stored. The code in this document will switch between directories as needed given the assumption they are all in the correct repository. **This step is required to execute the code without errors.**

# Data Processing

Before developing the specific statistics needed for the care board, the raw microdata files need to be compiled and converted into a proper format. The code in this section provides a methodology to pull in all required data, clean it as necessary, and export it to the required locations. This project uses a wide variety of data to compile its variety of statistics but the core data represents micro data from annual surveys conducted by the census bureau and the bureau of labor statistics. The monthly Current Population Survey (CPS) along with the yearly Annual Social and Economic Supplement (ASEC) and the annual American Time Use Survey (ATUS) are the largest used data sources for this project. We pull these data from the Minnesota Population Center (MPC) Integrated Public Use Microdata Series (IPUMS) project. The first step is introducing how these data are loaded in and transformed.

## CPS ASEC Data Download

The code below produces a major source of raw data used in the production of The Care Board statistics: CPS monthly and CPS ASEC yearly microdata. The **Current Population Survey Annual Social and Economic Supplement (CPS ASEC)** is a special supplement to the **monthly Current Population Survey (CPS)**, which is conducted by the U.S. Census Bureau and the Bureau of Labor Statistics (BLS). The **monthly CPS** is primarily focused on **labor force characteristics**, such as employment, unemployment, and workforce participation. The **CPS ASEC** goes beyond this by collecting detailed information on **income, poverty, health insurance coverage, and demographic characteristics**, making it the primary source of data for measuring income inequality and economic well-being in the U.S.

The **monthly CPS** is a regular survey of around 60,000 households conducted every month. The **CPS ASEC** is conducted **once a year**, typically in **March**, and includes both regular CPS respondents and additional over sampled households to improve estimates for specific population groups. The CPS ASEC expands the sample size compared to the **monthly CPS** by including **additional households** to improve data accuracy, especially for poverty and income statistics. The **CPS Monthly data** is used for labor force statistics like the unemployment rate while the **CPS ASEC data** is used for official poverty, estimates, income distribution studies, and health insurance coverage statistics. We utilize the **CPS ASEC** data to compile data on income and earnings for those working in the formal care economy.

The code below uses an IPUMS API key to download the IPUMS microdata files, which include the relevant information needed to develop statistics for The Care Board. **IPUMS (Integrated Public Use Microdata Series)** is a project that provides harmonized microdata from various national and international surveys and censuses. It is maintained by the **Minnesota Population Center** at the University of Minnesota. IPUMS makes large-scale individual- and household-level databases more accessible and comparable over time and across geographic regions.

The data available from IPUMS can be accessed through an API key. In order to replicate the code chunk below you will need to insert your personal key into the slot for set_ipums_api_key. For information on how to get a personal key visit https://www.ipums.org/. An IPUMS API key is free to the public and researchers.

IPUMS CPS data, including the ASEC supplements, can be cited as follows.

Sarah Flood, Miriam King, Renae Rodgers, Steven Ruggles, J. Robert Warren, Daniel Backman, Annie Chen, Grace Cooper, Stephanie Richards, Megan Schouweiler, and Michael Westberry. IPUMS CPS: Version 12.0 [dataset]. Minneapolis, MN: IPUMS, 2024. https://doi.org/10.18128/D030.V12.0

When downloading from this repository, we need to first identify the sample ids that represent the required samples. A set of files in the 01_preliminary-code-and-data file store the names of the required samples for both the asec and the CPS monthly data pulls. The key difference between these sample lists is the asec list contains only data from the yearly CPS ASEC data while the cps list contains all monthly sample iterations.

```{r Samples, eval=FALSE}
samples_asec <- read.csv("./data/CSV/ASECSampleIDs.csv")$ASEC_Sample_IDs
samples_cps <- read.csv("./data/CSV/CPSSampleIDs.csv")$CPS_Sample_IDs 
```

Following the creation of the samples, we also need to list a set of variables that we want to pull from the IPUMS repository. We create three set of variables. **var_common** refers specifically to var iables that are present in both the CPS ASEC and the CPS Monthly data. **var_asec** refers specifically to variables that are present only in the CPS ASEC data. These variables refer mostly to income and earnings data. **var_cps** refers specifically to variables that are present in the CPS Monthly data alone. These variables refer mostly to workforce classification variables. The chunk below populations these lists.

```{r Variables, eval=FALSE}
# Variables to extract
var_common <- c(
  "PERNUM",
  "REGION",
  "STATEFIP",
  "SEX",
  "RACE",
  "HISPAN",
  "AGE",
  "EDUC",
  "MARST",
  "MOMLOC",
  "POPLOC",
  "FAMSIZE",
  "NCHILD",
  "YNGCH",
  "IND1990",
  "OCC2010",
  "EMPSTAT",
  "WKSTAT",
  "AHRSWORKT",
  "ABSENT",
  "WHYABSNT"
)

var_asec <- c(
  var_common,
  "EARNWT",
  "UHRSWORKT",
  "INCWAGE",
  "POVERTY"
)

var_cps <- c(
  var_common,
  "LABFORCE",
  "SPLOC",
  "COMPWT",
  "TELWRKPAY",
  "CLASSWKR",
  "DIFFCARE",
  "NILFACT"  
)
```

The code below uses the **IPUMS API** interface to pull data from the **yearly CPS ASEC** and the  **CPS Monthly**. This R chunk is currently set to **NOT** run when this markdown file is run. The final results of this data extract can be found in the **GITHUB**. The code does not run so that all the following code uses the correct iteration or the API data. If you wish to modify the data downloaded from IPUMS simply change any of the samples or variables as you desire and then run the below chunk in an R script. If you wish to simply replicate the data conducted by The Care Board, you can skip this step and load in the ddi files already in the GITHUB repository.

```{r Download, eval=FALSE}
data_sets <- c("asec", "cps")

for(sel_data_set in data_sets){

  # Create data extract
  cps_ext_def <- define_extract_cps(
    description = "Care Variable Extract",
    samples = get(paste0("samples_", sel_data_set)),
    variables = get(paste0("var_", sel_data_set))
  )
  Sys.sleep(60)

  # Submit data extract request
  cps_ext_submitted <- submit_extract(cps_ext_def)
  cps_ext_complete <- wait_for_extract(cps_ext_submitted)
  Sys.sleep(60)

  # Download extract
  filepath <- download_extract(cps_ext_submitted, overwrite = TRUE)
  Sys.sleep(60)

  print(paste(sel_data_set, "data has been downloaded"))
}

print("API work has finished")
```

## ATUS Data Note

As a note, the IPUMS data API does not currently fully support the download of **ATUS data**. We provide the **xml** and **.dat.gz** file associated with the data in the **GITHUB repository** for The Care Board. To modify the ATUS data download by changing samples or variables, users will need to conduct a manual extract from IPUMS. The interface to conduct this manual extract along with instructions can be found as follows https://timeuse.ipums.org/. IPUMS kindly requests that usage of this data be cited as follows.

Sarah M. Flood, Liana C. Sayer, Daniel Backman, and Annie Chen. American Time Use Survey Data Extract Builder: Version 3.2 [dataset]. College Park, MD: University of Maryland and Minneapolis, MN: IPUMS, 2023. https://doi.org/10.18128/D060.V3.2


## Data Prep Functions

After running the above code **OR** by downloading the data from the **GITHUB** repository, we should have three sets of .xml and .dat.gz files. These files represent meta data and zipped downloads of the microdata from IPUMS. The code below is used to load this data into the R environment.

After loading the data into the R environment, we get the variable labels for each of the files. Before creating the statistics, we need to clean the data and ensure consistency between different samples. The CPS Monthly and CPS ASEC data often have variables that measure the same thing as the ATUS data but are coded slightly differently. Thus, we need to ensure that all variables are coded correctly. This section does that while also providing information on the variety of variables throughout the samples.


```{r IPUMS Pulls}
ipums_atus <- "./data/IPUMS Pulls/atus_00027.xml"
ipums_cps <- "./data/IPUMS Pulls/cps_00421.xml"
ipums_asec <- "./data/IPUMS Pulls/cps_00420.xml"

ddi_asec <- read_ipums_ddi(ipums_asec)
label_asec <- ddi_asec$var_info$var_label
lbl_tbl_asec <- ddi_asec$var_info$val_labels

ddi_cps <- read_ipums_ddi(ipums_cps)
label_cps <- ddi_cps$var_info$var_label
lbl_tbl_cps <- ddi_cps$var_info$val_labels

ddi_atus <- read_ipums_ddi(ipums_atus)
label_atus <- ddi_atus$var_info$var_label
lbl_tbl_atus <- ddi_atus$var_info$val_labels
```
### Asec Raw Variables

The tables below represent the different variables gathered from the CPS ASEC data. These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw asec}
label_asec
```


### CPS Raw Variables

The tables below represent the different variables gathered from the CPS Monthly data. These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw cps}
label_cps
```

### ATUS Raw Variables

The tables below represent the different variables gathered from the ATUS data. These variables are so far not tampered with and represent the exact values received when downloaded directly from the IPUMS repository.

```{r raw atus}
label_atus
```
The function below presents a methodology for comparing variables between data. This function takes the variable name in each data set and compares the value and labels together. For example, each data set has a variable for Hispanic, but they code this data slightly differently. The check_lookups function will, when the variable Hispanic is inserted, look at the different values to check for consistency. In the case that different samples have different values, we will need to recode them before moving forward.

```{r}
check_lookups <- function(sel_tbl){
  index_asec <- which(str_detect(label_asec, sel_tbl))
  index_cps <- which(str_detect(label_cps, sel_tbl))
  index_atus <- which(str_detect(label_atus, sel_tbl))
    
  if(length(index_asec) > 0){
    lu_asec <- lbl_tbl_asec[[index_asec]] |> 
      rename(lbl_asec = lbl)
  } else {
    lu_asec <- data.frame(val = NA, lbl_asec = NA)
  }
  
  if(length(index_cps) > 0){
    lu_cps <- lbl_tbl_cps[[index_cps]] |> 
      rename(lbl_cps = lbl)
  } else {
    lu_cps <- data.frame(val = NA, lbl_cps = NA)
  }
  
  if(length(index_atus) > 0){
    lu_atus <- lbl_tbl_atus[[index_atus]] |> 
      rename(lbl_atus = lbl)
  } else {
    lu_atus <- data.frame(val = NA, lbl_atus = NA)
  }

  lu_combined <- lu_asec |> 
    full_join(lu_cps, by = c("val")) |>
    full_join(lu_atus, by = c("val"))

  return(lu_combined)

}
```

## Creation of new variables

In addition to the variables generated directly from IPUMS, we create a few other variables of interest. These variables represent recoding numeric variables into categorical variables or combining multiple variables into a single variable for analysis. Each of these is coded specifically for The Care Board project.

### Age Category

This variable represents groupings of ages of individual respondents and acts as a categorical classifier for the different ages. For those under the age of 18, the category “Under 18” is used. For those over the age of sixty-five, the category “Over65” is used. For all other categories other than the 18-24, this variable represents ten-year increments.

```{r age category}
f_age_category <- function(col){
  lbl <- case_when(
    col < 18 ~ "Under 18",
    col >= 18 & col < 25 ~ "Eighteen/Twenty-Four",
    col >= 25 & col < 35 ~ "Twenty-Five/Thirty-Five",
    col >= 35 & col < 45 ~ "Thirty-Five/Forty-Five",
    col >= 45 & col < 55 ~ "Forty-Five/Fifty-Five",
    col >= 55 & col < 65 ~ "Fifty-Five/Sixty-Five",
    col >= 65 ~ "Sixty-Five Plus"
    )
  
  return(lbl)
}
```

### Prime Age

This variable identifies individuals who meet the labor economics definition of being in a “prime age” bin. Labor economists define prime age as those individuals aged 25 to 54. This age category represents people who tend to be most productive within the workforce. The ages are typically after higher education and before retirement.

```{r prime age}
f_prime_age <- function(col){
  lbl <- case_when(
    col < 25 ~ "Under Twenty-Five",
    col >= 25 & col < 55 ~ "Prime Age",
    col >= 55 ~ "Fifty-Five Plus"
    )
  
  return(lbl)
}
```

### Child Age

This variable looks within a house and identifies the age of the youngest child, putting that value within age bins. These age bins are under 5, 5-11, and 12-17 representing different aspects of a child’s growth. An additional category of eighteen plus represents adult children living with their parents while the variable NIU represents households without any children. This variable can be used as a categorical variables instead of the numeric child age variable when desired.

```{r}
f_child_age <- function(col){
  lbl <- case_when(
    col < 5 ~ "Under Five",
    col >= 5 & col < 12 ~ "Five_Eleven",
    col >= 12 & col < 18 ~ "Twelve_Eighteen",
    col >= 18 & col < 99  ~ "Eighteen Plus",
    col == 99  ~ "NIU"
    )
  
  return(lbl)
} 
```

### Gender_parent

This variable represents an interaction between the sex and parenthood status of an individual. This can be one of four unique values representing both the case where a respondent is male or female and the case where the respondent is a parent living with their children in the home or childless (including parents whose children live elsewhere). Parenthood includes step-parents and parents of both biological and adopted children.

```{r gender_parent}
f_gender_parent <- function(YNGCH, sex, AGE) {
  lbl <- case_when(
    YNGCH <= 18 & sex == "Female" & AGE >= 18 ~ "Mothers",
    YNGCH <= 18 & sex == "Male" & AGE >= 18 ~ "Fathers",
  
    YNGCH == 99 & sex == "Female" & AGE >= 18 ~ "Non-Mothers",
    YNGCH == 99 & sex == "Male" & AGE >= 18 ~ "Non-Fathers",
    
    TRUE ~ "Other"
  )
  
  return(lbl)
}
```

### Race Ethnicity

This variable coalesces the race variable and the Hispanic variable to create a single value of race_ethnicity. It is common practice to merge these variables adding a person of Hispanic origin to the race categories as a separate observation from other races. In the case where the respondent is not Hispanic, then this variable represents their reported survey race.

```{r}
f_race_ethnicity <- function(hispan, race){
  
  lbl <- ifelse(hispan == "Hispanic", "Hispanic", race)
  
  return(lbl)
}
```

### Laborstatus

This variable represents a combination of the variables wkstat and empstat. The variable empstat identifies a respondent’s labor force participation status as in the labor force, unemployed, or not in the labor force (NILF). The variable wkstat identifies a worker as full- or part-time on the condition that they are in the labor force. Labor status has four unique categories of full-time, part-time, unemployed, and NILF.

```{r laborstatus}
f_laborstatus <- function(wkstat, empstat){
  
  lbl <- ifelse(empstat == "Employed", wkstat, empstat)
  
  return(lbl)
}
```

### Month

This variable provides the name of the month as opposed to a numerical representation of the month for easier readability. This variable is most important for the CPS Monthly data that has monthly iterations of the data as opposed to the yearly CPS ASEC and ATUS.

```{r}
f_month <- function(col) {
  lbl <- recode(
    as.character(col),
    `1` = "January",
    `2` = "February",
    `3` = "March",
    `4` = "April",
    `5` = "May",
    `6` = "June",
    `7` = "July",
    `8` = "August",
    `9` = "September",
    `10` = "October",
    `11` = "November",
    `12` = "December"
  )
  
  return(lbl)
} 
```

## Catagorical Variable Comparisons

Now that we have coded our major categorical variables, we need to also ensure they are coded the same between the different surveys. To do this we use the lookup_compare function that we created previously. Using this function, we see the values of the different variables in the CPS ASEC and ATUS data.

For each variable the lookup_compare function provides the value as coded in CPS ASEC, CPS Monthly, and ATUS. For CPS ASEC and CPS Monthly this is generally the same, but for ATUS is often different. For example, the first value we look at is the variable representing Hispanic origin.



### Hispanic

```{r}
lookup_compare <- check_lookups("Hispanic origin")
lookup_compare
```

As can be seen, this variable is coded in more detail in the CPS Monthly data and the ATUS data. We thus need to ensure all data is coded in the same format. The functions below provide the methodology for converting the data in ATUS and the CPS Monthly data into the final values for the Hispanic origin data.

```{r}
f_hispanic_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `100` = "Not Hispanic",
    `9999` = "NIU",
    .default = "Hispanic"
    )
  
  return(lbl)
} 

f_hispanic_cps <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `0` = "Not Hispanic",
    `901` = "NIU",
    `902` = "NIU",
    .default = "Hispanic"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    hispan_cps = f_hispanic_cps(val),
    hispan_atus = f_hispanic_atus(val)
  ) |> 
  relocate(hispan_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Race

The code below provides the same methodology for recoding the Race variables to be identifical.

```{r}
lookup_compare <- check_lookups("Race")
lookup_compare
```


```{r}
f_race_atus <- function(col){

  lbl <- dplyr::recode(
    as.character(col),
    `100` = "White",
    `110` = "Black",
    `120` = "American Indian",
    `130` = "Asian/Pacific Island",
    `131` = "Asian/Pacific Island",
    `132` = "Asian/Pacific Island",
    `9999` = "NIU",
    .default = "Two or More Races"
    )
  
  return(lbl)
} 

f_race_cps <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `100` = "White",
    `200` = "Black",
    `300` = "American Indian",
    `650` = "Asian/Pacific Island",
    `651` = "Asian/Pacific Island",
    `652` = "Asian/Pacific Island",
    .default = "Two or More Races"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    race_cps = f_race_cps(val),
    race_atus = f_race_atus(val)
  ) |> 
  relocate(race_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Sex

The code below provides the same methodology for recoding the sex variable.

```{r}
lookup_compare <- check_lookups("Sex")
lookup_compare
```


```{r}
f_sex <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `1` = "Male", 
    `2` = "Female", 
    `9` = "NIU",
    `99` = "NIU",      
    )
  
  return(lbl)
} 


lookup_KU_labels <- lookup_compare |> 
  mutate(
    sex = f_sex(val),
  ) 

lookup_KU_labels
```

### Marital Status

The code below provides the same methodology for recoding the marital status variable.

```{r}
lookup_compare <- check_lookups("Marital status")
lookup_compare
```


```{r}
f_marst <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `1` = "Married",
    `2` = "Married",
    `3` = "Separated, Widowed, or Divorced",
    `4` = "Separated, Widowed, or Divorced",
    `5` = "Separated, Widowed, or Divorced",
    `6` = "Single-Never-Married",
    `7` = "Separated, Widowed, or Divorced",
    `9` = "NIU",
    `99` = "NIU",      
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    marst = f_marst(val)
  )

lookup_KU_labels
```

### Education

The variable below provides the same methodology for recoding the educaiton variable.

```{r}
lookup_compare <- check_lookups("Education|school")
lookup_compare
```

```{r}
f_educ_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
     `999` = "NIU",
     `10` = "No HS Diploma",
     `11` = "No HS Diploma",
     `12` = "No HS Diploma",
     `13` = "No HS Diploma",
     `14` = "No HS Diploma",
     `15` = "No HS Diploma",
     `16` = "No HS Diploma",
     `17` = "No HS Diploma",
     `20` = "High School",
     `21` = "High School",
     `30` = "Some College",
     `31` = "Some College",
     `32` = "Some College",
     `80` = "Some College",
     `110` = "Some College",
     `40` = "Bachelor's Degree",
     `41` = "Graduate Degree",
     `42` = "Graduate Degree",
     `43` = "Graduate Degree"
    )
  
  return(lbl)
} 

f_educ_cps<- function(col){
  
  lbl <- case_when(
    col == 999 ~ "Missing/Unknown",
    col <= 1 ~ "NIU",
    col >= 2 & col <= 72 ~ "No HS Diploma",
    col == 73 ~ "High School",
    col >= 80 & col <= 110  ~ "Some College",
    col >= 120 & col <= 122  ~ "Some College",
    col == 111 ~ "Bachelor's Degree",
    col >= 123 ~ "Graduate Degree"
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    educ_cps = f_educ_cps(val),
    educ_atus = f_educ_atus(val)
  ) |> 
  relocate(educ_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Poverty

The code below provides the same methodology for the poverty variable.

```{r}
lookup_compare <- check_lookups("poverty")
lookup_compare
```

```{r}
f_poverty_asec <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `0` = "NIU",
    `10` = "Below Poverty",
    `20` = "Above Poverty",
    `21` = "100-124 Percent of Poverty",
    `22` = "125-149 Percent of Poverty",
    `23` = "150+ Percent of Poverty"    
    )
  
  return(lbl)
} 

f_poverty_atus <- function(col){
  
  lbl <- dplyr::recode(
    as.character(col),
    `10` = "Below Poverty",
    `11` = "Below Poverty",
    `12` = "Below Poverty",
    `20` = "Above Poverty",
    .default = "NIU"     
    )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    pov_asec = f_poverty_asec(val), 
    pov_atus = f_poverty_atus(val)
  ) |> 
  relocate(pov_asec, .after = "lbl_asec")

lookup_KU_labels
```

### Labor Force Status

The code below provides the same methodology for the Labor Force Status variable.

```{r}
lookup_compare <- check_lookups("Labor force status")
lookup_compare
```

```{r}
f_labforce_atus <- function(col){
  
  lbl <- case_when(
    col >= 1 & col <= 4 ~ "In the Labor Force",
    col == 5 ~ "Not in the Labor Force",
    col == 99 ~ "NIU"
    )
  
  return(lbl)
} 

f_labforce_cps <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 1 ~ "Not in the Labor Force",
    col == 2 ~ "In the Labor Force"
    )

  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    labforce_cps = f_labforce_cps(val), 
    labforce_atus = f_labforce_atus(val)
  ) |> 
  relocate(labforce_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Employment Status

The code below provides the same methodology for the Employment Status variable.


```{r}
lookup_compare <- check_lookups("Employment status")
lookup_compare
```

```{r}
f_empstat_cps <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 1 ~ "Armed Forces",
    col %in% c(10, 12) ~ "Employed",
    col >= 20 & col <= 22~ "Unemployed",
    col >= 30 & col <= 36~ "NILF"
    )
  
  return(lbl)
} 

f_empstat_atus <- function(col) {
  lbl <- recode(
    as.character(col),
    `1` = "Employed",
    `2` = "Employed",
    `3` = "Unemployed",
    `4` = "Unemployed",
    `5` = "NILF"
  )
  
  return(lbl)
}

lookup_KU_labels <- lookup_compare |> 
  mutate(
    empstat_cps = f_empstat_cps(val), 
    empstat_atus = f_empstat_atus(val)
  ) |> 
  relocate(empstat_cps, .after = "lbl_cps")

lookup_KU_labels
```

### Work Status

The code below provides the same methodology for the variables identifiying full or part time status.

```{r}
lookup_compare <- check_lookups("Full or part time status")
lookup_compare
```

```{r}
f_wkstat <- function(col){
  
  lbl <- case_when(
    col >= 10 & col <= 15 ~ "Full Time",
    col >= 20 & col <= 22 ~ "Part Time",
    col >= 40 & col <= 42 ~ "Part Time",
    col %in% c(50, 60) ~ "Unemployed",
    col == 99 ~ "NIU"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    wkstat = f_wkstat(val),
  ) |> 
  relocate(wkstat, .after = "lbl_cps")

lookup_KU_labels
```

### Class of Worker

The code below provides the same methodology for analyzing worker classes.

```{r classwkr compare}
lookup_compare <- check_lookups("Class of worker")
lookup_compare
```

```{r classwkr recode}
f_classwkr <- function(col){
  
  lbl <- case_when(
    col == 0 ~ "NIU",
    col == 99 ~ "Missing/Unknown",
    col %in% c(10, 13, 14) ~ "Self_Employed",
    col >= 20 & col <= 23 ~ "Wage/Salary",
    col >= 24 & col <= 28 ~ "Government",
    col == 29 ~ "Unpaid"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    classwkr = f_classwkr(val),
  ) |> 
  relocate(classwkr, .after = "lbl_cps")

lookup_KU_labels
```

### NILF

The code below uses the same methodology for the question analyzing why someone is not in the labor force.,

```{r nilf compare}
lookup_compare <- check_lookups("NILF")
lookup_compare
```

```{r nilf recode}
f_nilf_actvity <- function(col){
  
  lbl <- case_when(
    col == 1 ~ "Disabled",
    col == 2 ~ "Ill",
    col == 3 ~ "School",
    col == 4 ~ "Homemaker",
    col == 6 ~ "Other",
    col == 99 ~ "NIU"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    nilf_activity = f_nilf_actvity(val),
  ) |> 
  relocate(nilf_activity, .after = "lbl_cps")

lookup_KU_labels
```

### Telework

The code below provides the same methodology for the varibale asking if someone works via telework.

```{r telework compare}
lookup_compare <- check_lookups("telework")
lookup_compare
```

```{r telework recode}
f_telwrkpay <- function(col){
  
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `1` = "Teleworked",
    `2` = "No Telework"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    telwrkpay = f_telwrkpay(val),
  ) |> 
  relocate(telwrkpay, .after = "lbl_cps")
```


### Absenteeism

```{r}
lookup_compare <- check_lookups("Absent")
lookup_compare
```

```{r}
f_absent <- function(col){
  
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `1` = "No",
    `2` = "Yes, Laid Off",
    `3` = "Yes, Other"
    )
 
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    absent = f_absent(val),
  ) |> 
  relocate(absent, .after = "lbl_cps")

lookup_KU_labels
```

### Reason for Absent

The code below provides the same methodology for the variable representing the reson why someone was not at work.

```{r reason compare}
lookup_compare <- check_lookups("Reason")
lookup_compare
```

```{r why absent function}
f_whyabsnt <- function(col) {
  lbl <- recode(
    as.character(col),
    `0` = "NIU",
    `5` = "Vacation/Personal days",
    `6` = "Own illness/medical problem",
    `7` = "Care Reason",
    `8` = "Care Reason",
    `9` = "Care Reason",
    `10` = "Non-Care Reason",
    `11` = "Non-Care Reason",
    `12` = "Non-Care Reason",
    `13` = "Non-Care Reason",
    `15` = "Other"
  )
  
  return(lbl)
} 

lookup_KU_labels <- lookup_compare |> 
  mutate(
    whyabsnt = f_whyabsnt(val),
  ) |> 
  relocate(whyabsnt, .after = "lbl_cps")

lookup_KU_labels
```

### Recoding all Variables

The functions created above provide the methodology to recode all needed variables. The code chunk below creates a general function that uses these above functions to recode the variables ensuring that all CPS Monthly, CPS ASEC, and ATUS samples have identical variable values. Additionally, the code below ensures that numeric variables are correctly coded and provides mutations to data variables to ensure they are all the same format.

The functions in the chunk below are split for variables in all samples, variables in both the ASEC and CPS Monthly, and variables in each of the unique samples. For a reminder of which variables are in which, see the variable classifications previously discussed. Finally, this code chunk creates the final column order which will be used to ensure that all data sets have their variables in the same order.


```{r Recoding Functions}

recode_all_common <- function(df) {
  if("MONTH" %in% names(df)){
    df <- df |> 
      mutate(date = 
               as.Date(paste(YEAR, MONTH, "01", sep = "-")))
  } else {
    df <- df |> 
      mutate(date = as.Date(paste(YEAR, "01-01", sep = "-")))
  }
  
  df <- df |>
    mutate(
      id = row_number(),
      nchild = as.numeric(NCHILD),
      child_age = f_child_age(YNGCH),
      age_category = f_age_category(AGE),
      prime_age = f_prime_age(AGE),
      sex = f_sex(SEX),
      marst = f_marst(MARST), 
      gender_parent = f_gender_parent(YNGCH, sex, AGE)
    )
  
  return(df)
}


recode_asec_cps <- function(df) {
  df <- df |>
    mutate(
      statefip = as_factor(STATEFIP),
      region = as_factor(REGION),
      famsize = as.numeric(FAMSIZE),
      month = f_month(MONTH),
      
      hispan = f_hispanic_cps(HISPAN),
      race = f_race_cps(RACE),
      race_ethnicity = f_race_ethnicity(hispan, race),
      educ = f_educ_cps(EDUC),

      wkstat = f_wkstat(WKSTAT),     
      empstat = f_empstat_cps(EMPSTAT), 
      laborstatus = f_laborstatus(wkstat, empstat),      
      absent = f_absent(ABSENT),
      whyabsnt = f_whyabsnt(WHYABSNT)
    )
  
  return(df)
}

recode_asec <- function(df) {
  df <- df |>
    mutate(
      pernum = as.numeric(PERNUM),
      momloc = as.numeric(MOMLOC),
      poverty = f_poverty_asec(POVERTY)
    )
  
  return(df)
}

recode_cps <- function(df) {
  df <- df |>
    mutate(
      labforce = f_labforce_cps(LABFORCE),
      classwrk = f_classwkr(CLASSWKR),
      telwrkpay = f_telwrkpay(TELWRKPAY),
      nilf_activity = f_nilf_actvity(NILFACT)
    )
  
  return(df)
}

recode_atus <- function(df) {
  df <- df |>
    mutate(
      day = case_when(
        DAY == 1 ~ "Sunday",
        DAY == 2 ~ "Monday",
        DAY == 3 ~ "Tuesday",
        DAY == 4 ~ "Wednesday",
        DAY == 5 ~ "Thursday",
        DAY == 6 ~ "Friday",
        DAY == 7 ~ "Saturday"
      ),
      
      poverty = f_poverty_atus(POVERTY185),
      hispan = f_hispanic_atus(HISPAN),
      race = f_race_atus(RACE),
      race_ethnicity = f_race_ethnicity(hispan, race),
      
      empstat = f_empstat_atus(EMPSTAT),
      educ = f_educ_atus(EDUC)
    )
    
  return(df)
}

col_order <- c(
  "id",
  "YEAR",
  "SERIAL",
  "MONTH",
  "month",
  "DAY",
  "date",
  
  "CPSID",
  "ASECFLAG",
  "HFLAG",
  "ASECWTH",
  "COMPWT",
  "WT06",
  "WT20",
  "HWTFINL",
  "WTFINL",
  "pernum",
  "CASEID",
  "STRATA",
  
  "REGION",
  "region",
  "STATEFIP",
  "statefip",
  
  "PERNUM",
  "CPSIDP",
  "CPSIDV",
  "ASECWT",
  
  "AGE",
  "age_category",
  "prime_age",
  
  "SEX",
  "sex",

  "HISPAN",
  "hispan",
  "RACE",
  "race",
  "race",
  "race_ethnicity",
  
  "MARST",
  "marst",
  "MOMLOC",
  "momloc",
  "POPLOC",
  "SPLOC",

  "gender_parent",
  "HH_SIZE",
  "FAMINCOME",
  "HH_NUMADULTS",
  "FAMSIZE",
  "famsize",
  "NCHILD",
  "nchild",
  "YNGCH",
  "child_age",
  
  "EDUC",
  "educ",
  
  "EMPSTAT",
  "empstat",
  "laborstatus",
  "OCC2010",
  "IND1990",
  "UHRSWORKT",
  "AHRSWORKT",
  "ABSENT",
  "absent",
  "WHYABSNT",
  "whyabsnt",
  "WKSTAT",
  "wkstat",
  
  "EARNWT",
  "INCWAGE",
  "POVERTY",
  "poverty",

  "LABFORCE",
  "labforce",
  "CLASSWKR",
  "classwkr",
  "NILFACT",
  "nilf_activity",
  "DIFFCARE",
  "TELWRKPAY",
  "telwrkpay",

  "KIDWAKETIME",
  "KIDBEDTIME",
  "POVERTY185",
  "LINENO",
  "OCC2",
  "OCC_CPS8",
  "EARNWEEK",
  "HRSWORKT_CPS8",
  "SPEMPSTAT",
  "ECPRIOR",
  "ACTLINE",
  "ACTIVITY",
  "DURATION_EXT",
  "DURATION",
  "SCC_ALL_LN",
  "SCC_OWN_LN",
  "SEC_ALL_LN",
  "START",
  "STOP",
  
  "activity",
  "developmental",
  "health",
  "daily_living",
  "paid_work",
  "formal_work",
  "child_care",
  "elder_care",
  "householdcare",
  "selfcare",
  "leisure",
  "sleeping",
  "volunteering",
  "education"
)
```

## Loading the Activity Data

In The Care Board methodology, we specifically develop methods to compare both formal paid and informal unpaid activities and time use. We create crosswalks from the data to code all activities as either care activities or not and with a specific care focus for care related activities. The classification of jobs and activities as part of the care economy or not represents a major source of assumptions and decision points. We acknowledge there are many ways to classify some of these detailed activities and that others might have differing opinions about how best to classify them. We thus provide the crosswalks for full transparency, analysis, and review.

The first crosswalk presents the classification of formal occupations as parts of the care economy or not. This crosswalk uses federal **standard occupational classification codes (SOC)** and for each SOC, labels it as developmental care, daily living care, health care, or none.

```{r load occupations}
df_occ <- fread("./data/CSV/Formal_Occupation_Crosswalk.csv")
df_occ
```

The second crosswalk presents the classification of informal time use activities as part of the care economy or not. This crosswalk uses the ATUS activity codes and for each activity, labels it as developmental care, daily living care, health care, or none.

```{r load activities}
df_act <- fread("./data/CSV/ATUSActivityCrossover.csv") |> 
  clean_names()
df_act
```


## CPS Monthly Variable Processing

Now that we have investigated the variables across our different samples, we need to apply the various functions above to each of our datasets to recode them to fit the proper format. We start with the CPS Monthly data. The code below uses the ddi file to load in all CPS Monthly data and then applies the functions to recode the variables, assemble them in the correct order, and merge them with the activity coding data. It then saves the files as an rds file for future use.



```{r recode cps data}
# Read data
ddi_cps <- "./data/IPUMS Pulls/cps_00421.xml"
micro_cps <- read_ipums_micro(ddi_cps)

# Apply data processing functions to base table to get desired standard output
micro_cps <- micro_cps |> 
  recode_all_common() |> 
  recode_asec_cps() |> 
  recode_cps() |>
  select(any_of(col_order)) |> 
  left_join(df_occ, by = c("OCC2010" = "code"))

skim(micro_cps)
```


## CPS Asec Variable Processing

The code below does the same thing applying the functions created to recode the data for the CPS ASEC variables. This code then assembles the data in the proper order and merges them with the activity data.

```{r recode asec data}
# Read data
ddi_asec <- "./data/IPUMS Pulls/cps_00420.xml"
micro_asec <- read_ipums_micro(ddi_asec)

# Apply data processing functions to base table to get desired standard output
micro_asec <- micro_asec |> 
  recode_all_common() |> 
  recode_asec_cps() |> 
  recode_asec() |>
  select(any_of(col_order)) |> 
  left_join(df_occ, by = c("OCC2010" = "code")) 

skim(micro_asec)

rm(micro_asec)
gc()
```

## ATUS Variable Processing

The code below uses the functions created to recode the ATUS variables. This code then assembles the data in the proper order and merges them with the activity data. Following this, this code merges ATUS data with occupation data from the CPS Monthly data. For understanding formal care economy work, we rely on responses in the CPS Monthly data and use the CPSIDP variable to merge between the ATUS and CPS Monthlly datasets. The ATUS is conducted among a subset of individuals in the month when they leave the CPS Monthly data rotation. We use the data from the last month an individual is present in the CPS Monthly to identify their formal occupation status for the ATUS data.

```{r recode atus data}
ddi_atus <- "./data/IPUMS Pulls/atus_00027.xml"

# Read data
micro_atus <- read_ipums_micro(ddi_atus)

# Apply data processing functions to base table to get desired standard output
micro_atus <- micro_atus |> 
  recode_all_common() |> 
  recode_atus() |> 
  left_join(df_act, by = c("ACTIVITY" = "code")) |>
  select(any_of(col_order)) |> 
  mutate(
    act_care_focus = case_when(
      developmental == 1 ~ "developmental",
      daily_living == 1 ~ "daily_living", 
      health == 1 ~ "health", 
      TRUE ~ "non-care"
    )
  ) 

# Get occupation care_focus labels from cps data where available
cps_occ <- micro_cps |> 
  filter(YEAR >= min(micro_atus$YEAR)-3) |> 
  group_by(CPSIDP) |> 
  filter(date == max(date)) |> 
  ungroup() |> 
  select(CPSIDP, date, occ_care_focus) 

rm(micro_cps)
gc()

act_types <- c("developmental", "health", "daily_living",
               "paid_work", "formal_work", "child_care",
               "elder_care", "householdcare", "selfcare",     
               "leisure", "sleeping", "volunteering",
               "education")

micro_atus <- micro_atus |> 
  left_join(
    cps_occ |> 
      rename(cps_date = date), 
    by = c("CPSIDP")
    ) |> 
  mutate(
    across(c(developmental, health, daily_living,
      paid_work, formal_work, child_care, elder_care,
      householdcare, selfcare, leisure, sleeping, 
      volunteering, education), 
      ~replace_na(., 0)))

skim(micro_atus)
```


## Data Processing Conclusion

The code in this section has provided the methodology for downloading, cleaning, summarizing, and saving the data used for developing the statistics in The Care Board project. This section is essential for understanding the replication methodologies to go from completely raw data to the data used to compile our statistics. The code above saves 3 separate datasets for the CPS monthly files, the yearly CPS ASEC files, and yearly ATUS files. Upon the complete running of this code, three datasets should be written into the proper working directory.

# Care and care provision

Understanding how much time in a given day a person requires care is essential for accurately assessing the scale and structure of the care economy. While caregiving can be measured using a variety of methods, time-based measurements provide a more granular and human-centered view of care than simple headcounts or categorical designations of dependency. They help differentiate between levels of care intensity and the allocation of resources across health and social service systems. Furthermore, time-use data allows researchers and policymakers to model scenarios of unmet care needs and evaluate how demographic shifts, such as population aging or rising rates of disability, will affect demand for care services in both formal and informal sectors.

This information is also foundational for estimating the economic value of caregiving. Many individuals who require care do not receive it through formal markets but rely instead on family members or community networks. Without quantifying the time demands associated with caregiving needs, it is difficult to assess the hidden costs borne by households or to design equitable social support programs. Accurately capturing time needs can reveal care deficits and stress points in existing systems, thus informing policies aimed at improving accessibility, equity, and wellbeing outcomes for care recipients.

Equally important is understanding how much time the average person spends providing care on a daily basis. Capturing this data highlights the often-invisible labor that sustains households and communities, particularly the unpaid and gendered work frequently carried out by women. By quantifying caregiving as a time commitment, researchers can estimate its opportunity costs—such as foregone earnings, education, or leisure—and more comprehensively assess its impact on individual wellbeing and economic productivity. This information is crucial for designing interventions, from tax credits to caregiver respite programs, that acknowledge and support the vital contributions of care providers.

Moreover, time-use data on caregiving offers a powerful tool for comparative policy analysis. It enables cross-population comparisons, tracking how caregiving varies by age, gender, socioeconomic status, and family structure. It also facilitates longitudinal studies of how caregiving responsibilities evolve over the life course or in response to social policy changes. Embedding time-based care metrics into national surveys and economic accounts can help integrate care work into the broader understanding of labor markets, social reproduction, and economic development, thereby strengthening the case for investing in the care economy as both a moral and strategic priority.

The first section of The Care Board, What Is the Care Economy, uses a variety of methods to create measurements of average time we need care and how much time we have available to provide care. The code in the next few sections comes with many assumptions and simplifications. It is vital that in the futue more data be collected to provide better estimates on the following outcomes, but for now, this code represents our most complete work on estimating care need and provision by individuals across society.

## Age Data

```{r child = "market.qmd"}
```

## Market Datum

```{r child = "market_datum.qmd"}
```

# Providers of Care

The next section of the care board looks at different groups that are providing care. We construct a dataset below that looks at care provision across different groups to understand who the care providers are in society. This then feeds into the Sankey diagram in the Care Board which is used to understand the flow of caregiving throughout the population.

```{r child = "care_provider.qmd"}
```

#Provider Diversity

```{r child = "provider.qmd"}
``` 

# Activity Time data

Collecting data on specific care-related activities across both the formal and informal sectors is vital for a comprehensive understanding of the care economy. By disaggregating care work into its constituent activities—such as nursing, home health assistance, cleaning, teaching, feeding, or emotional support—we gain a clearer picture of the full range and diversity of labor that underpins human well-being and social reproduction. Calculating metrics like the average time spent on each care activity and the corresponding wages earned allows us to evaluate not only the volume of care being provided, but also the economic value placed on different forms of care. This granular approach is particularly important in revealing the undervaluation of essential work, much of which is disproportionately performed by women, people of color, and immigrants.

Detailed activity-level data is also critical for crafting targeted and effective policy interventions. It allows researchers and decision-makers to identify gaps in compensation, exposure to physical and emotional strain, or mismatches between time demands and available support systems. For example, data showing long hours in unpaid eldercare alongside low wages for professional caregivers may point to the need for investment in long-term care infrastructure or wage floors in care occupations. Similarly, tracking time spent on caregiving tasks in educational or domestic contexts can highlight the blurred lines between formal employment and informal labor. Without this specificity, the care economy remains abstract, obscuring the real conditions of care workers and the needs of care recipients. Collecting and analyzing this level of detail helps make visible the full scope of care labor and strengthens the foundation for equitable and sustainable care systems.

## Formal Care Activities

```{r child = "activity_formal.qmd"}
```

## Informal Care Activities

```{r child = "activity_informal.qmd"}
```


# Care Gini Coefficient

The **Gini coefficient** is a widely used statistical measure of inequality within a distribution, commonly applied to income or wealth. It ranges from 0 to 1, where 0 represents perfect equality (everyone has the same amount) and 1 indicates perfect inequality (one person has everything, and everyone else has nothing). The Gini coefficient is often visualized through a **Lorenz curve**, which plots the cumulative share of a resource (like income or jobs) against the cumulative share of the population. The further the Lorenz curve deviates from the line of perfect equality, the higher the Gini coefficient, and the more unequal the distribution.

In the context of the **care economy**, the Gini coefficient offers a powerful lens for understanding the geographic or demographic distribution of **care-related jobs** (e.g., childcare workers, home health aides, elder care providers) relative to the population **in need of care** (such as young children, elderly individuals, or people with disabilities). A low Gini coefficient in this setting would suggest that care jobs are relatively evenly distributed among communities based on their level of need, indicating a more equitable alignment of service availability. Conversely, a high Gini coefficient implies that care jobs are concentrated in certain areas or populations, leaving other high-need areas underserved. This kind of analysis is especially important for identifying care deserts—areas with a high demand for care services but few available workers—so policymakers and planners can better target resources and interventions to reduce inequality and improve access to essential care.
The Gini Coefficient of Formal Care measures how formal care jobs are geographically distributed across the U.S. among those individuals at risk of needing care. A Gini Coefficient of 0 would indicate perfect equality, meaning formal care jobs are evenly located in areas where at risk individuals reside. A higher Gini Coefficient signals a greater mismatch in the availability of care by location. A Gini Coefficient usually measures income inequality, but here we use it to measure spatial inequality of care services to the population most at-risk of needing those services.

To calculate the GINI coefficient, we use county-level data on employment in the care economy coupled with the distribution of population. We start by loading in data tables obtained from the U.S. Census Bureau and data from the Quarterly Census of Employment and Wages (QCEW). Both data sources include county-level data.


```{r child = "gini.qmd"}
```

# Care Ratio


The **Care Ratio** is a novel demographic and economic metric designed to quantify balance between care providers and care recipients within a given population. Building on the logic of a traditional dependency ratio used in demographic studies, the Care Ratio advances the concept by incorporating both the diversity of caregiving roles and the differentiated needs of care recipients. The numerator represents the population of potential caregivers, stratified and weighted according to their caregiving contributions. This includes formal sector care workers, unpaid caregivers such as homemakers, and a residual category of individuals not formally engaged in care but who may nonetheless contribute to informal care networks. The denominator consists of the at-risk care-dependent population, including children, the elderly, and individuals with disabilities—each subgroup weighted by the intensity or frequency of care they typically require. This framework provides a more nuanced picture of the care landscape than traditional economic or demographic indicators.

The Care Ratio is critical for the economics of care and related demographic analyses because it brings into focus the structural balance—or imbalance—between those who provide care and those who depend on it. In an era of aging populations, declining fertility rates, and shifting labor market dynamics, the burden of care is increasingly a central challenge for societies. The Care Ratio offers a standardized, comparative tool that can be used to assess the sustainability of care systems, identify regions or groups at risk of care deficits, and inform social policy aimed at redistributing care labor more equitably. By moving beyond simple counts and integrating the complexity of care work and need, this measure helps bridge gaps between demographic modeling, social policy, and lived experience, providing a foundation for developing more responsive and equitable care infrastructures.

We start by loading in a variety of datasets related to age, disability, and employment by county.

```{r child = "care_ratio.qmd"}
```

# The Sandwhich Generation

The **Sandwich Generation** refers to a group of adults who are simultaneously caring for their own children while also providing care or support to aging parents. This dual responsibility places unique emotional, financial, and time burdens on caregivers, often leading to stress, work-life conflict, and economic strain. In the economics of care, the sandwich generation exemplifies how unpaid and invisible care labor supports the functioning of both the family and broader society. Understanding this is crucial as demographic shifts, such as increased life expectancy and delayed childbearing, intensify these care demands.

Measuring the size and characteristics of the sandwich generation is essential for informing public policy, labor protections, and social support systems. Capturing accurate numbers and understanding the demographic profile of this group, such as gender, income, employment status, and race/ethnicity, can help reveal the hidden costs of informal care and shape interventions that better support multigenerational caregivers. Recognizing their role is vital, not just for their wellbeing, but also for sustaining the broader care economy.

This section provides the code and outcomes used to provide the statistics related to the care economy. To understand the sandwich generation, we use ATUS data. We only use years after 2010 because the year 2011 is the first year to ask questions about secondary elder care activities. The chunk below loads in the data and selects the requested variables.

```{r child = "sandwich_generation.qmd"}
```


#Broad Indicators

```{r child = "broad_impacts.qmd"}
```


# Expanded Data

```{r child = "expanded_data_compilation.qmd"}
```

# Conclusion


This methodology document has outlined the comprehensive framework behind *The Care Board*, detailing the data sources, processing pipelines, statistical methods, and visualization strategies employed in its development.
By bringing together multiple datasets, coding procedures, and analytical models, this document provides a transparent account of how the indicators on *The Care Board* are generated, interpreted, and updated. Whether the data pertains to formal care infrastructure, informal caregiving time, or population-level needs, each component has been carefully constructed to provide a robust, scalable, and replicable platform for monitoring and analyzing care-related dynamics.

The aim of *The Care Board* is not just to present statistics, but to contextualize them—illuminating the patterns, disparities, and evolving trends that define the care economy across time and place.
By linking rigorous data analysis with user-friendly visualization, the board supports decision-making for researchers, policymakers, and advocates who are invested in strengthening the care infrastructure. This document ensures that the metrics presented are not black boxes, but rather the product of thoughtful methodological choices grounded in social science and data science principles.

Looking forward, this methodology will remain a living framework—capable of evolving as new data becomes available, as care dynamics shift, and as users provide feedback.
The ongoing development of *The Care Board* will continue to prioritize transparency, adaptability, and impact, ensuring it remains a vital tool for understanding and improving care systems in diverse communities.



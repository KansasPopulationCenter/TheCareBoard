summarise(
weight = median(weight),
geo_level = first(geo_level),
gender = first(gender),
provider_status = first(provider_status)
)
population_df <- cp_pop |>
summarise(
population = sum(weight),
.by = c(geo_level, gender, provider_status)
)
population_df$geo_level <- sprintf("%02d", as.numeric(population_df$geo_level))
population_df$geo_level <- paste0("state", population_df$geo_level)
# Join time estimates with population denominators
cp_informal_state <- cp_summary |>
left_join(population_df, by = c("geo_level", "gender", "provider_status"))
# Prepare national records with harmonized variables
cp_informal_nation <- cp_informal |>
mutate(
gender = str_to_lower(sex),
provider_status = case_when(
gender_parent %in% c("Mothers", "Fathers") ~ "with_children",
gender_parent %in% c("Non-Mothers", "Non-Fathers") ~ "without_children",
TRUE ~ "other"
),
care_type = "informal",
provider_attention = case_when(
metric == "scc_all_ln" ~ "passive_child",
metric == "sec_all_ln" ~ "passive_elder",
TRUE ~ "active"
),
care_focus = case_when(
metric == "scc_all_ln" ~ "developmental",
metric == "sec_all_ln" ~ "health",
act_care_focus == "non-care" ~ "none",
TRUE ~ act_care_focus
),
time_use = ifelse(care_focus == "none", "non_care", "care"),
weight = wt06 / 365 / 5,
geo_level = "national",
race = race_ethnicity
) |>
filter(duration != 0)
# Individual-level aggregation, then weight to the population
cp_summary <- cp_informal_nation |>
summarise(
total_time = sum(duration),
weight = median(weight),
.by = c(
year, caseid, weight, geo_level, gender, provider_status, time_use,
care_type, care_focus, provider_attention
)
) |>
summarise(
provision_interval = sum(total_time * weight),
.by = c(
geo_level, gender, provider_status, time_use,
care_type, care_focus, provider_attention
)
)
# National population denominators (daily weight)
cp_pop <- cp_informal_nation |>
group_by(caseid) |>
summarise(
weight = median(weight),
geo_level = first(geo_level),
gender = first(gender),
provider_status = first(provider_status)
)
population_df <- cp_pop |>
summarise(
population = sum(weight),
.by = c(gender, provider_status)
)
# Join time estimates with population denominators
cp_informal_nation <- cp_summary |>
left_join(population_df, by = c("gender", "provider_status"))
# Combine state and national unpaid-care datasets
cp_informal <- rbind(cp_informal_state, cp_informal_nation)
# Optional: inspect distributions
cp_informal %>% skim()
summary(cp_combined)
cp_combined <- bind_rows(
cp_formal,
cp_informal
)  |>  # pipe to next step
arrange(care_type, time_use, gender, provider_status, care_focus) %>%
# Select subset of columns
select(geo_level, gender, provider_status, time_use, care_type,
care_focus, provider_attention, provision_interval, population) %>%
rename(geo = geo_level)%>%
# Filter rows based on conditions
filter(population != "null")
write.csv(cp_combined, "./app_data/care_provider_datum.csv",
row.names = FALSE)
summary(cp_combined)
cp_disp <- cp_combined |>
rename(
Geo = geo,
Gender = gender,
`Provider Status` = provider_status,
`Time Use` = time_use,
`Care Type` = care_type,
`Care Focus` = care_focus,
`Provider Attention` = provider_attention,
`Provision Interval` = provision_interval,
Population = population
)
# Identify numeric columns for right-align & formatting
num_cols <- c("Provision Interval", "Population")
# Build the datatable
datatable(
cp_disp,
rownames = FALSE,
filter = "top",                # per-column search inputs
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",              # Buttons, filter, table, pagination
buttons = list(
list(extend = "copy", title = "cp_combined"),
list(extend = "csv",  title = "cp_combined"),
list(extend = "excel",title = "cp_combined"),
list(extend = "print")
),
fixedHeader = TRUE,          # sticky header when scrolling
colReorder = TRUE,
autoWidth = TRUE,
# Right-align numeric columns
columnDefs = list(
list(className = "dt-right", targets = which(names(cp_disp) %in% num_cols) - 1)
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Care Provision Summary (interactive: filter columns, reorder, and export)"
)
) |>
# Format large numbers with commas for readability
formatCurrency(num_cols, currency = "", interval = 3, mark = ",")
library(DT)
library(dplyr)
library(scales)
cp_disp <- cp_combined |>
rename(
Geo = geo,
Gender = gender,
`Provider Status` = provider_status,
`Time Use` = time_use,
`Care Type` = care_type,
`Care Focus` = care_focus,
`Provider Attention` = provider_attention,
`Provision Interval` = provision_interval,
Population = population
)
# Identify numeric columns for right-align & formatting
num_cols <- c("Provision Interval", "Population")
# Build the datatable
datatable(
cp_disp,
rownames = FALSE,
filter = "top",                # per-column search inputs
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",              # Buttons, filter, table, pagination
buttons = list(
list(extend = "copy", title = "cp_combined"),
list(extend = "csv",  title = "cp_combined"),
list(extend = "excel",title = "cp_combined"),
list(extend = "print")
),
fixedHeader = TRUE,          # sticky header when scrolling
colReorder = TRUE,
autoWidth = TRUE,
# Right-align numeric columns
columnDefs = list(
list(className = "dt-right", targets = which(names(cp_disp) %in% num_cols) - 1)
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Care Provision Summary (interactive: filter columns, reorder, and export)"
)
) |>
# Format large numbers with commas for readability
formatCurrency(num_cols, currency = "", interval = 3, mark = ",")
summary(cp_population)
cp_population <- asec  |>  # pipe to next step
# Create or modify columns
mutate(
gender = str_to_lower(sex),
geo = statefip,
provider_status = case_when(
gender_parent %in% c("Mothers", "Fathers") ~ "with_children",
gender_parent %in% c("Non-Mothers", "Non-Fathers") ~ "without_children",
TRUE ~ "other")
) |>  # pipe to next step
# Aggregate data to compute summary statistics
summarise(population = sum(asecwt), .by = c(geo, gender, provider_status))  |>  # pipe to next step
arrange(gender, provider_status)
cp_population$geo <- sprintf("%02d", as.numeric(cp_population$geo))
cp_population$geo <- paste0("state", cp_population$geo)
### NATIONAL LEVEL
cp_population_national <- asec  |>  # pipe to next step
# Create or modify columns
mutate(
gender = str_to_lower(sex),
geo = statefip,
provider_status = case_when(
gender_parent %in% c("Mothers", "Fathers") ~ "with_children",
gender_parent %in% c("Non-Mothers", "Non-Fathers") ~ "without_children",
TRUE ~ "other")
) |>  # pipe to next step
# Aggregate data to compute summary statistics
summarise(population = sum(asecwt), .by = c(gender, provider_status))  |>  # pipe to next step
arrange(gender, provider_status)  |>  # pipe to next step
# Create or modify columns
mutate(geo = "national")
cp_population <- rbind(cp_population, cp_population_national)
write.csv(cp_population, "./app_data/care_provider_population.csv",
row.names = FALSE)
summary(cp_population)
# Presentation-friendly names
cp_pop_disp <- cp_population |>
rename(
Geo = geo,
Gender = gender,
`Provider Status` = provider_status,
Population = population
)
# Build interactive table
datatable(
cp_pop_disp,
rownames = FALSE,
filter = "top",
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",
buttons = list(
list(extend = "copy",  title = "cp_population"),
list(extend = "csv",   title = "cp_population"),
list(extend = "excel", title = "cp_population"),
list(extend = "print")
),
fixedHeader = TRUE,
colReorder = TRUE,
autoWidth = TRUE,
columnDefs = list(
list(className = "dt-right", targets = 3)  # right-align Population
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Population by Geo, Gender, and Provider Status (interactive)"
)
) |>
formatCurrency("Population", currency = "", interval = 3, mark = ",")
# Loads packages, global options, and plotting theme(s)
# (Make sure load_defaults.R calls library(tidyverse), library(janitor), library(scales), etc.)
source("load_defaults.R")
gc()
# Loads packages, global options, and plotting theme(s)
# (Make sure load_defaults.R calls library(tidyverse), library(janitor), library(scales), etc.)
source("load_defaults.R")
# Create a complete single-year age index (0, 1, ..., 85)
# Note: age 80 ≡ ages 80–84; age 85 ≡ ages 85+ (see Overview above)
age_list <- data.frame(age = seq(0, 85, by = 1))
# Load latest ASEC microdata and keep only age and weight
age_data <- read.csv("./data/CSV/ASECdata.csv") |>
filter(YEAR == max(YEAR)) |>
select(AGE, ASECWT) |>
clean_names()
# age_modified will contain one row per age (0–85) and the weighted population.
# The full_join ensures ages with no records appear with population = 0.
age_modified <- full_join(
age_list,
age_data |>
group_by(age) |>
summarise(population = sum(asecwt, na.rm = TRUE)),
by = "age"
) |>
mutate(population = coalesce(population, 0))
# Save processed data for the app
write.csv(age_modified, "./app_data/market.csv", row.names = FALSE)
# Plot a simple age distribution from a data frame with columns `age` and `population`
plt_dist <- function(df) {
p <- ggplot() +
geom_col(
data = df,
aes(x = age, y = population)
) +
theme_minimal() +
theme(axis.title = element_blank()) +
scale_y_continuous(labels = scales::comma) +
ggtitle(label = paste(
"total population:",
scales::comma(sum(age_modified$population))
))
return(p)
}
# Render the plot
plt_dist(age_modified)
summary(age_modified)
# Friendly column names
age_disp <- age_modified |>
rename(
Age = age,
Population = population
)
datatable(
age_disp,
rownames = FALSE,
filter = "top",
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",
buttons = list(
list(extend = "copy",  title = "age_modified"),
list(extend = "csv",   title = "age_modified"),
list(extend = "excel", title = "age_modified"),
list(extend = "print")
),
fixedHeader = TRUE,
colReorder = TRUE,
autoWidth = TRUE,
columnDefs = list(
list(className = "dt-right", targets = c(1, 2)) # right-align Age & Population
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Population by Single Year of Age (interactive)"
)
) |>
# no decimals for Age
formatRound("Age", digits = 0) |>
# commas for Population
formatCurrency("Population", currency = "", interval = 3, mark = ",")
# Friendly column names
age_disp <- age_modified |>
rename(
Age = age,
Population = population
)
datatable(
age_disp,
rownames = FALSE,
filter = "top",
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",
buttons = list(
list(extend = "copy",  title = "age_modified"),
list(extend = "csv",   title = "age_modified"),
list(extend = "excel", title = "age_modified"),
list(extend = "print")
),
fixedHeader = TRUE,
colReorder = TRUE,
autoWidth = TRUE,
columnDefs = list(
list(className = "dt-right", targets = c(1, 2)) # right-align Age & Population
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Population by Single Year of Age (interactive)"
)
) |>
# no decimals for Age
formatRound("Age", digits = 0) |>
# commas for Population
formatCurrency("Population", currency = "", interval = 3, mark = ",")
age_disp <- age_modified |>
rename(Age = age, Population = population)
# Compute valid 0-based targets dynamically
targets_right <- seq_along(age_disp) - 1  # c(0, 1)
datatable(
age_disp,
rownames = FALSE,
filter = "top",
extensions = c("Buttons", "FixedHeader", "ColReorder", "Responsive"),
options = list(
pageLength = 25,
lengthMenu = c(10, 25, 50, 100),
dom = "Bfrtip",
buttons = list(
list(extend = "copy",  title = "age_modified"),
list(extend = "csv",   title = "age_modified"),
list(extend = "excel", title = "age_modified"),
list(extend = "print")
),
fixedHeader = TRUE,
colReorder = TRUE,
autoWidth = TRUE,
columnDefs = list(
list(className = "dt-right", targets = targets_right)
)
),
caption = htmltools::tags$caption(
style = "caption-side: top; text-align:left; font-weight:600; font-size:1.05em; margin-bottom:8px;",
"Population by Single Year of Age (interactive)"
)
) |>
formatRound("Age", digits = 0) |>
formatCurrency("Population", currency = "", interval = 3, mark = ",")
gc()
# Load project defaults / helpers
source("load_defaults.R")
# Read input data
age_modified <- read.csv("./app_data/market.csv")
market_datum <- age_modified |>
# Create all combinations across dimensions
cross_join(data.frame(care_focus = c("developmental", "daily_living", "health")))
# Read IPUMS ATUS Household/Person files (relationship fields)
library(ipumsr)
ddi_file <- read_ipums_ddi("./data/IPUMS Pulls/atus_00029.xml")
atus_hh   <- read_ipums_micro(ddi_file) |> clean_names()
# Join relationship info to activity rows via caseid + activity line
atus <- atus |>
left_join(
atus_hh |> select(caseid, actlinew, relatew),
by = c("caseid" = "caseid", "actline" = "actlinew")
)
# Read ATUS activity microdata (activity-level records)
atus <- read.csv("./data/CSV/ATUSdata.csv") %>%
select(
YEAR, CASEID, WT06, ACTLINE, HH_SIZE, AGE, marst, nchild,
activity, act_care_focus, occ_care_focus,
paid_work, child_care, elder_care, sleeping,
DURATION, SCC_ALL_LN, SEC_ALL_LN
) %>%
clean_names() %>%
# Remove a known bad ID if required by data notes
filter(caseid != 20220402221228)
# Keep the 5 most recent years, excluding 2020 (pandemic anomaly year)
years_include <- atus |>
distinct(year) |>
filter(year != 2020) |>
arrange(desc(year)) |>
slice_head(n = 5) |>
pull()
# Restrict ATUS to selected years and prepare working variables
atus <- atus |>
filter(year %in% years_include) |>
rename(care_focus = act_care_focus) |>
mutate(
# care_job flags occupations with any care focus
care_job  = ifelse(occ_care_focus == "none", 0, 1),
# Convert ATUS annual weight to an average daily weight over 5 years
weight    = wt06 / 365 / 5,
# Work time attributable to paid care work (used in provision construction)
work_time = duration * paid_work * care_job
)
prepare_overrides <- function(care_interval, age_ranges, col_name) {
care_override <- do.call(rbind, lapply(names(care_interval), function(age_range) {
data <- care_interval[[age_range]]
df <- data.frame(
age_range = age_range,
care_focus = names(data),
interval = as.numeric(data)
)
return(df)
}))
care_override <- care_override |>
# Join tables
left_join(age_ranges, by = "age_range", relationship = "many-to-many") |>
select(age, care_focus, interval) |>
rename({{col_name}} := interval)
return(care_override)
}
age <- age_modified$age
needs_atus_calc <- list()
for (a in age) {
# 1) Restrict to individuals with NO caregiving (primary or secondary) anywhere in their diary
data <- atus |>
group_by(caseid) |>
filter(all(scc_all_ln == 0)) |>
filter(all(sec_all_ln == 0)) |>
filter(all(child_care == 0)) |>
filter(all(elder_care == 0)) |>
ungroup() |>
# Keep care activities only (exclude "non-care")
filter(care_focus != "non-care") |>
# Living alone (household size = 1) and reference person
filter(hh_size == 1) |>
filter(relatew == 100) |>
# Stabilize with a ±2-year window around age a
filter(age %in% c(a - 2, a - 1, a, a + 1, a + 2))
# 2) Aggregate per person, then compute weighted mean by care_focus
data <- data |>
reframe(
duration = sum(duration, na.rm = TRUE),  # total minutes per person
weight   = first(weight),                # person-level daily weight
.by = c(care_focus, caseid)
) |>
reframe(
need_interval = weighted.mean(duration, w = weight, na.rm = TRUE),
.by = c(care_focus)
) |>
mutate(age = a)
if (nrow(data) > 0) needs_atus_calc[[a]] <- data
}
